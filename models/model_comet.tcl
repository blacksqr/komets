set DEFINE_MODEL_COMET 1 

#_________________________________________________________________________________________________________
proc Trace {C m} {
 set cmd    "method $C $m {[gmlObject info arglist $C $m]} {\n"
 append cmd "puts \"\$objName $m "
   foreach a [gmlObject info arglist $C $m] {
     append cmd {$} [lindex $a 0] " "
    }
 append cmd "\"\n"
 append cmd [gmlObject info body $C $m]
 append cmd "}"
 
 eval $cmd
}

#_________________________________________________________________________________________________________
  proc CSS++ {root args} {
    set cmd {};
    foreach a $args {append cmd $a { }}
    #puts "Style_CSSpp Interprets $cmd $root"; 
    return [Style_CSSpp Interprets $cmd $root]
   }

#_________________________________________________________________________________________________________
#____________________________________________ COMET POOL for all _________________________________________
#_________________________________________________________________________________________________________
method CometPool constructor {} {
  set this(unique_id) 0
  set this(L_free) [list]
  set this(L_used) [list]
}

#_________________________________________________________________________________________________________
method CometPool get_a_unique_name {} {
 incr this(unique_id)
 return ${objName}_COMET_$this(unique_id)
}

#_________________________________________________________________________________________________________
method CometPool Release_comets {Lc} {
 foreach c $Lc {this Release_a_comet $c}
}

#_________________________________________________________________________________________________________
method CometPool Release_a_comet {c} {
 $c set_daughters_R ""
 foreach m [$c get_out_mothers] {
   if {[catch "$m Sub_daughter_R $c" err]} {$m Sub_daughter_R $c}
  }
 set t1 [llength $this(L_used)]
 set this(L_used) [lremove $this(L_used) $c]
 set t2 [llength $this(L_used)]
 if {$t2 < $t1} {
   lappend this(L_free) $c
  }
}

#_________________________________________________________________________________________________________
method CometPool get_a_comet {type args} {
 set rep ""
 foreach c $this(L_free) {
   if {[lsearch [gmlObject info classes $c] $type] != -1} {
     set this(L_free) [lremove $this(L_free) $c]
	 set rep $c
	 break
    }
  }
 
 if {[string equal $rep ""]} {
   set rep [this get_a_unique_name]
   $type $rep "a $type nammed $rep" "Generated by $objName"
  }
  
 lappend this(L_used) $rep
 eval "$rep configure $args"
 return $rep
}

if {![gmlObject info exists object CPool]} {CometPool CPool}

#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
proc Generate_accessors {class_name L_vars} {
 foreach v $L_vars {
   set    cmd "method $class_name get_$v \{ \} \{"
   append cmd {return $this(} $v ")\}"
     eval $cmd
   set    cmd "method $class_name set_$v \{v\} \{"
   append cmd {set this(} $v ") \$v\}"
     eval $cmd
  }
}

#_________________________________________________________________________________________________________
# A comet is composed of three kind of elements, namely:
#  - a logical consistency part : its aims to maintain consistence between logical models.
#  - some logical models : each of them modelises an aspect of the comet. Typically a comet
#                          has 2 logical models. One for the interaction and one for the functionnal core.
#                          A L.M. aims to manage differents concrete models.
#  - some concrete models : each of them is associated to a logical model.
#                           A C.M. aims to be the interface to a core implementing the model.
#                           For exemple a C.M. of the presentation of a button could be the
#                           interface to the TK code.
#_________________________________________________________________________________________________________
proc Add_Semantic_API_infos_to_contructor {get_set classe L_methodes} {
# Edit the constructor to add informations about the semantic API
 set n_txt_constr "method $classe constructor {[gmlObject info args $classe constructor]} {"
 set nb_this_API 0; set nb_return 0
 set txt_constr [gmlObject info body $classe constructor]
 set L_lines [split $txt_constr "\n"]
 set done 0
 foreach line $L_lines {
   if {[regexp {^ *set this(Semantic_API_$get_set) .*$} $line reco]} {
     append n_txt_constr " set this(Semantic_API_$get_set) \[list $L_methodes\]\n"
	 set done 1
    } else {if {$done == 0 && [regexp {^(.*)return(.*)$} $line reco avant apres]} {
	          append n_txt_constr " set this(Semantic_API_$get_set) \[list $L_methodes\]\n${avant}return$apres\n"
			  set done 1
	         } else {append n_txt_constr $line "\n"}
	       }
  }
 if {$done == 0} {append n_txt_constr " set this(Semantic_API_$get_set) \[list $L_methodes\]\n"}
 append n_txt_constr "}"
 eval $n_txt_constr
}

#_________________________________________________________________________________________________________
proc Methodes_get_LC {classe L_methodes o_reference} {
 Add_Semantic_API_infos_to_contructor get $classe $L_methodes
 
# Add methods to the class 
 set rep [list]
 foreach methode $L_methodes {set    cmd "method $classe "
                                 set methode_name [lindex $methode 0]
                                 set params       [lindex $methode 1]
                                 append cmd $methode_name " \{"
                                 #// Adding parameters
                                 foreach param $params {#// Managing the parameters
                                                        append cmd $param " "}
                               append cmd "\} \{"
                                 #// Default comportment is to call equivalent funcion for each Logical Model
                                 append cmd {return [} $o_reference { } $methode_name { }
                                   foreach param $params {append cmd {$} [lindex [lindex $param 0] 0] " "}
                                 append cmd {]}
                               append cmd "\}"
                               eval $cmd
                               append rep $cmd "\n"
                              }
 return $rep
}
#_________________________________________________________________________________________________________
proc Methodes_set_LC {classe L_methodes o_reference attrib_L} {
 Add_Semantic_API_infos_to_contructor set $classe $L_methodes
 
# Add methods to the class 
 set rep [list]
 foreach methode $L_methodes {set    cmd "method $classe "
                                 set methode_name [lindex $methode 0]
                                 set params       [lindex $methode 1]
                                 append cmd $methode_name " \{"
                                 #// Adding parameters
                                 foreach param $params {#// Managing the parameters
                                                        append cmd $param " "}
                              append cmd "\} \{"
                                if {[string equal $o_reference {}]} {} else {
                                  append cmd $o_reference { } $methode_name { }
                                    foreach param $params {append cmd {$} [lindex [lindex $param 0] 0] " "}
                                  append cmd ";\n"
                                 }
                                #// Default comportment is to call equivalent function for each element of the list attrib_L
                                if {[llength $attrib_L]} {
                                  append cmd {foreach LM } $attrib_L { } "\{" {$LM } $methode_name { }
                                    foreach param $params {append cmd {$} [lindex [lindex $param 0] 0] { }}
                                  append cmd "\}"
                                 }
                              append cmd "\}"
                              eval $cmd
                              append rep $cmd "\n"
                             }
 return $rep
}

#_________________________________________________________________________________________________________
proc Inject_code {C mtd code_bgn code_end} {
 set body   [gmlObject info body    $C $mtd]
 set L_args [gmlObject info arglist $C $mtd]
 
 set cmd "method $C $mtd {$L_args} {\n$code_bgn; $body\n$code_end}"
 
 eval $cmd
}

#_________________________________________________________________________________________________________
proc Manage_CallbackList {c L_m pos args} {
 set L_varL_to_declare_in_constr [list]
 foreach m $L_m {
# Init the callback mechanism
   set body   [gmlObject info body    $c $m]
   set L_args [gmlObject info arglist $c $m]
   set argL   [gmlObject info args    $c $m]

   set L_CB_name "this\(L_CB_$m\)"
   lappend L_varL_to_declare_in_constr $L_CB_name
   set cmd "method $c Trigger_L_CB_$m \{L_CB args\} \{\n"
     append cmd " foreach CB \[subst \$\$L_CB\] \{\n"
     append cmd "   eval \""
       set p 0; foreach a $argL {append cmd "set $a \{\[lindex \$args $p\]\}; "; incr p}
                foreach a $args {append cmd "set $a \{\[lindex \$args $p\]\}; "; incr p}
     append cmd "\[lindex \$CB 1\]\"\n"
     append cmd "  \}\n"
   append cmd "\}\n"
   eval $cmd
# Generate the callback accessors
   eval "Generate_accessors $c L_CB_$m"
# Generate the callback accessors for subscribing
   set cmd "method $c Subscribe_to_$m \{id CB \{UNIQUE \{\}\}\} \{\n"
     append cmd " if \{\[string equal \$UNIQUE \{\}\]\} \{\} else \{\n"
     append cmd "   set L \{\}\n"
     append cmd "   foreach CB_current \$$L_CB_name \{\n"
     append cmd "     if \{\[string equal \$id \[lindex \$CB_current 0\]\]\} \{\} else \{lappend L \$CB_current\}\n"
     append cmd "    \}\n"
     append cmd "   set $L_CB_name \$L\n"
     append cmd "  \}\n"
     append cmd " lappend $L_CB_name \[list \$id \$CB\];\n"
   append cmd "\}\n"
   eval $cmd
# Generate the callback accessors for unsubscribing
   set cmd "method $c UnSubscribe_to_$m \{id\} \{\n"
     append cmd " set L \{\}\n"
     append cmd " foreach CB \$$L_CB_name \{\n"
     append cmd "   if \{\[string equal \$id \[lindex \$CB 0\]\]\} \{\} else \{lappend L \$CB\}\n"
     append cmd "  \}\n"
     append cmd " set $L_CB_name \$L;\n"
   append cmd "\}\n"
   eval $cmd
# Generate the callback mechanism
   set cmd "method $c $m \{$L_args\} \{\n"
     if {[regexp "(.*)# INSERT CALLBACKS HERE(.*)" $body rep avant apres]} {
       append cmd $avant {# INSERT CALLBACKS HERE} "\n"
       append cmd " this Trigger_L_CB_$m $L_CB_name"
         foreach a $argL {append cmd " \$$a"}
         foreach a $args {append cmd " \$$a"}
       append cmd "\n" $apres
      } else {switch $pos {
                begin {append cmd " this Trigger_L_CB_$m $L_CB_name"
                         foreach a $argL {append cmd " \$$a"}
                         foreach a $args {append cmd " \$$a"}
                       append cmd "\n" $body "\n"
                      }
                end   {append cmd $body "\n"
                       append cmd " this Trigger_L_CB_$m $L_CB_name"
                         foreach a $argL {append cmd " \$$a"}
                         foreach a $args {append cmd " \$$a"}
                       append cmd "\n"
                      }
               }
             }
   append cmd "\}\n"
   eval $cmd
  }

# Add initialisation of lists of callbacks in the constructor
 set old_body [gmlObject info body    $c constructor]
 set argL [gmlObject info arglist $c constructor]
 set body "\n#___________________________________\n#Definition of some callback lists |\n#___________________________________\n"
 foreach CB $L_varL_to_declare_in_constr {
   append body " set $CB \[list\]\n"
  }
 append body $old_body

 set cmd "method $c constructor \{$argL\} \{\n"
   append cmd $body
 append cmd "\}\n"
 eval $cmd
}

#_________________________________________________________________________________________________________
proc Ensure_consistency {obj val} {
 set L_obj  [$obj Val_MetaData Manage_consistency_between_L_obj]
 if {$val != [$obj Val_MetaData Manage_consistency_between_val]} {
   puts "Ensure_consistency $obj:\n  - L_obj : $L_obj"
   foreach o $L_obj {
     set op_set [$o Val_MetaData Manage_consistency_between_op_set]
     set      v [$o Val_MetaData Manage_consistency_between_val]
     puts "$obj $val / $o $v"
     if {$val != $v} {$o Add_MetaData Manage_consistency_between_val $val; $o $op_set $val}
    }
  }
}

#_________________________________________________________________________________________________________
proc Manage_consistency_between {L_ObjOp_getOp_set_v} {
 set L_obj {}
 foreach ObjOp_getOp_set_v $L_ObjOp_getOp_set_v {lappend L_obj [lindex $ObjOp_getOp_set_v 0]}
 foreach ObjOp_getOp_set_v $L_ObjOp_getOp_set_v {
   set o      [lindex $ObjOp_getOp_set_v 0]
   set op_get [lindex $ObjOp_getOp_set_v 1]
   set op_set [lindex $ObjOp_getOp_set_v 2]
   set v      [lindex $ObjOp_getOp_set_v 3]

   $o Add_MetaData Manage_consistency_between_L_obj  $L_obj
   $o Add_MetaData Manage_consistency_between_op_get $op_get
   $o Add_MetaData Manage_consistency_between_op_set $op_set
   $o Add_MetaData Manage_consistency_between_val    [$o $op_get]
   $o Subscribe_to_$op_set Manage_consistency_between_L_obj "Ensure_consistency \$objName \$v" UNIQUE
  }
}

#_________________________________________________________________________________________________________
proc Eval_in_context {L_var_val args} {
 #puts "L_var_val = {$L_var_val}"
 foreach {var val} $L_var_val {set $var $val}
 eval [subst $args]
}

#_________________________________________________________________________________________________________
proc Encapsulator {type element args} {
 set name "Encapsulator_of_$element"
 $type $name $args

 return $name
}

#_________________________________________________________________________________________________________
#_____________________________________Common structure of elements________________________________________
#_________________________________________________________________________________________________________
method Comet_element constructor {name descr args} {
 set this(name)  $name
 set this(descr) $descr
 set this(unique_CG_id) 0
 
 set this(GDD_id) {}

# Lists of predecessors and predecessors
 set this(nb_max_mothers)   99999999
 set this(nb_max_daughters) 99999999
 set this(L_mothers)        [list]
 set this(L_daughters)      [list]
 set this(nesting_element)  {}
# List of out predecessors and successor, udefull to distinguish between nested comets and other ones
# Those list are sublist of L_mothers and L_daughters !!!
 set this(L_last_nested_daughters_subbed) {}

# A handle for evolution engines
 set this(L_E_engine) {}
 set this(handle_EE)  {}
#   set a0 [New_analyser]; set this(analyser)  [$a0 A_${objName}_$a0]
#   this Add_EE $this(analyser)
#   this set_Handle_EE $this(analyser)

# Semantic API
 set this(Semantic_API_get) {}
 set this(Semantic_API_set) {}
#______________________________________
 set this(FC)         {}
 set this(propagate_next_liste_cmd) {}
 set this(propagate_prev_liste_cmd) {}
 set this(is_propagating)            0
# Data structure for composition
## All the composing comets
 set this(L_composing_comets)        {}
 set this(composing_extension)       {}
## All the toplevel comets, subset of the set of composing comets, used to be connected to this cometPart
 set this(L_handle_composing_comets) {}
## All the sublevel comets, subset of the set of composing comets, used to be connected to the daughters.
 set this(L_handle_composing_daughters) {}

 set this(last_daughter_added) {}

 set this(consistency_phase) 0

# Marks
 set this(L_marks) {}

#___________________ Styles ___________________
 set this(style_class) {}
 set this(base_classes) [gmlObject info classes $objName]
 set this(names_obj)    $objName
 set this(style)        {}
 set this(styler)       {}
 if {[info exist class(DSL_GDD_QUERY)]} {} else {set class(DSL_GDD_QUERY) {}}
 if {[info exist class(DSL_CSSpp)    ]} {} else {set class(DSL_CSSpp)     {}}
 if {[info exist class(DSL_ECA)      ]} {} else {set class(DSL_ECA)       {}}

 set this(default_op_gdd_file)    [Comet_files_root]Common_GDD_requests.css++
 set this(default_css_style_file) ""
 set this(default_css_style_still_applied) 0
 
#______________________________________
 eval "$objName configure $args"
 return $objName
}

#_________________________________________________________________________________________________________
method Comet_element dispose {} {
 set L_m $this(L_mothers)
 set L_d $this(L_daughters)
 set L_c $this(L_composing_comets)
 set L_e $this(L_E_engine)

 foreach c $L_m {if {[catch "$c Basic_Sub_daughter $objName" err]} {puts "_-_-_-_-_-_-_- ERROR $c Basic_Sub_daughter $objName DISPOSE:\n$err"; }}
 set L [this get_out_daughters]
 Add_list L $this(L_daughters)
 foreach c $L   {if {[catch "$c Basic_Sub_mother   $objName" err]} {puts "_-_-_-_-_-_-_- ERROR $c Basic_Sub_mother $objName DISPOSE:\n$err"; }}

 foreach lc $L_m {$lc Sub_daughter $objName}
 foreach lc $L_d {$lc Sub_mother   $objName}
 foreach sc $L_c {if {[catch "$sc dispose" err]} {puts "_-_-_-_-_-_-_- ERROR in $objName dispose (composing comet) \n  $sc dispose failed:\n$err\n_-_-_-_-_-_-_-"; }}
 foreach ee $L_e {$ee dispose}

 set nesting_node [this get_nesting_element]
 if {![string equal $nesting_node {}]} {$nesting_node Sub_composing_comet $objName}
 
 this inherited
}

#_________________________________________________________________________________________________________
#______________________________________________ MetaDatas ________________________________________________
#_________________________________________________________________________________________________________
method Comet_element Has_MetaData {var}     {return [info exists this(metadata,$var)]}
method Comet_element Add_MetaData {var val} {set this(metadata,$var) $val}
method Comet_element Sub_MetaData {var}     {if {[catch "unset this(metadata,$var)" res]} {return 0} else {return 1}}
method Comet_element Val_MetaData {var}     {return $this(metadata,$var)}

#_________________________________________________________________________________________________________
# Used when deletion occur...
method Comet_element Basic_Sub_daughter {d} {
 Sub_list this(nesting_element)              $d
 Sub_list this(L_composing_comets)           $d
 Sub_list this(L_handle_composing_comets)    $d
 Sub_list this(L_handle_composing_daughters) $d
 Sub_list this(L_daughters)                  $d
}
method Comet_element Basic_Sub_mother   {m} {Sub_list this(L_mothers) $m}

#_________________________________________________________________________________________________________
Generate_accessors Comet_element [list default_css_style_still_applied default_css_style_file default_op_gdd_file GDD_id nesting_element Semantic_API_get Semantic_API_set]

#_________________________________________________________________________________________________________
method Comet_element Apply_default_style {} {
 Apply_style_on $objName [list] [this get_default_op_gdd_file] [this get_default_css_style_file]
 set this(default_css_style_still_applied) 1
}

#_________________________________________________________________________________________________________
method Comet_element get_ancestors {} {
 set L {}
 foreach m [this get_mothers] {
   lappend L $m
   foreach a [$m get_ancestors] {lappend L $a}
  }
 return $L 
}

#_________________________________________________________________________________________________________
method Comet_element get_ancestors_and_self {} {
 set L [this get_ancestors]
 return [linsert $L 0 $objName]
}

#_________________________________________________________________________________________________________
method Comet_element Eval {cmd} {
 #puts "\n______ $objName Eval:\n$cmd\n_________\n"
 set cmd [string map [list --- "\n"] $cmd]
 if {[catch "set obj $objName; $cmd" err]} {puts "Error in $objName Eval {$cmd}\n  -command was : set obj $objName; $cmd\n  -Error is : $err"}
 
 #set obj $objName;
 #foreach line [split $cmd "\n"] {
 #  if {[catch $line err]} {puts "Error in $objName Eval {$line}\n  -Error is : $err"}
 # } 
}

#___________________________________________________________________________________________________________________________________________
method Comet_element get_Params {} {
 set L ""
 foreach {var val} [array get this PARAMS,*] {
   lappend L [string range $var 7 end] $val
  }
 return $L
}

#___________________________________________________________________________________________________________________________________________
method Comet_element Add_Params {L_var_val} {
 foreach {var val} $L_var_val {
   set this(PARAMS,$var) $val
  }
}

#___________________________________________________________________________________________________________________________________________
method Comet_element Sub_Params {L_var_val} {
 foreach {var val} $L_var_val {
   unset this(PARAMS,$var)
  }
}

#___________________________________________________________________________________________________________________________________________
method Comet_element Has_Params {L_var} {
 foreach {var val} [array get this PARAMS,*] {
   set var [string range $var 7 end]
   foreach v $L_var {if {$v == $var} {return 1}}
  }
 return 0
}

#___________________________________________________________________________________________________________________________________________
method Comet_element Val_Param {v} {
 return $this(PARAMS,$v)
}

#_________________________________________________________________________________________________________
method Comet_element set_Var {var val}  {set this(ctxt,$var) $val}
method Comet_element exists_Var {var}  {return [info exist this(ctxt,$var)]}
method Comet_element get_Var {var}  {
 if {[info exist this(ctxt,$var)]} {return $this(ctxt,$var)}
 return {}
}

#_________________________________________________________________________________________________________
method Comet_element get_DSL_GDD_QUERY {}  {return $class(DSL_GDD_QUERY)}
method Comet_element set_DSL_GDD_QUERY {v} {set class(DSL_GDD_QUERY) $v}

#_________________________________________________________________________________________________________
method Comet_element get_DSL_CSSpp { } {return $class(DSL_CSSpp)}
method Comet_element set_DSL_CSSpp {v} {set class(DSL_CSSpp) $v}

#_________________________________________________________________________________________________________
method Comet_element get_DSL_ECA { } {return $class(DSL_ECA)}
method Comet_element set_DSL_ECA {v} {set class(DSL_ECA) $v}

#_________________________________________________________________________________________________________
Generate_List_accessor Comet_element style_class style_class
Generate_List_accessor Comet_element L_marks     L_marks
Generate_accessors     Comet_element [list style styler]

#_________________________________________________________________________________________________________
method Comet_element get_COMET_id {} {return $objName}

#_________________________________________________________________________________________________________
method Comet_element get_L_roots {} {
 set L {} 
 if {[llength $this(L_mothers)] == 0} {
   return $objName
  } else {foreach M $this(L_mothers) {Add_list L [$M get_L_roots]}
         }
 return $L
}

#_________________________________________________________________________________________________________
method Comet_element Has_for_styles {Ls} {
 foreach s $Ls {
   if {[this Has_for_style $s]} {} else {return 0}
  }
 return 1
}

#_________________________________________________________________________________________________________
method Comet_element Has_for_style {s} {
 if {[lsearch $this(style_class)  $s] != -1} {return 1}
 if {[lsearch $this(base_classes) $s] != -1} {return 1}
 if {[lsearch $this(names_obj)    $s] != -1} {return 1}
 return 0
}

#_________________________________________________________________________________________________________
#______________________________________________________________________________
method Comet_element Add_arg {txt_name arg} {
 upvar $txt_name txt
 if {[llength $arg] > 1 || $arg == ""} {
   append txt " {" $arg "}"
  } else {append txt " $arg"}
}

#______________________________________________________________________________
method Comet_element configure args {
 set L_cmd {}; set cmd ""
 foreach arg $args {
   if {[string equal -length 1 - $arg]} {
     if {[regexp {^.[0-9].*$} $arg]} {
	   this Add_arg cmd $arg
	  } else {lappend L_cmd $cmd; set cmd [string range $arg 1 end]
	         }
	} else {this Add_arg cmd $arg}
  } 
 lappend L_cmd $cmd
 
 foreach cmd $L_cmd {
   if {[string equal $cmd {}]} {continue}
   if {[string equal [string index $cmd 0] | ]} {
     set cmd [string range $cmd 1 end]
     eval $cmd
    } else {eval "$objName $cmd"}
  }
}

#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
method Comet_element Empty_out_daughter {} {
 set L_out [this get_out_daughters]
 foreach e $L_out {this Sub_daughter $e}
}

#_________________________________________________________________________________________________________
method Comet_element Update {} {}

#_________________________________________________________________________________________________________
method Comet_element Substitute_by {e} {
#puts "<${objName}::Comet_element::Substitute_by $e>"
 set L_out_daughters [this get_out_daughters]
 set L [this get_mothers]
 foreach PM_M $L {
   set pos [lsearch [$PM_M get_out_daughters] $objName]
   if {$pos == -1} {set pos [lsearch [$PM_M get_daughters] $objName]}
   if {[string equal $PM_M [this get_nesting_element]]} {
     set nested 1
	 set L_nested_comets    [$PM_M get_L_composing_comets]
	   set nested_pos         [lsearch $L_nested_comets $objName]
	   if {$nested_pos != -1} {set L_nested_comets     [lreplace $L_nested_comets   $nested_pos $nested_pos $e]}
	 set L_nested_handle    [$PM_M get_handle_composing_comet]
	   set nested_pos         [lsearch $L_nested_handle $objName]
	   if {$nested_pos != -1} {set L_nested_handle     [lreplace $L_nested_handle   $nested_pos $nested_pos $e]}
	 set L_nested_daughters [$PM_M get_handle_comet_daughters]
	   set nested_pos         [lsearch $L_nested_daughters $objName]
	   if {$nested_pos != -1} {set L_nested_daughters [lreplace $L_nested_daughters $nested_pos $nested_pos $e]}
	} else {set nested 0}
   $PM_M Sub_daughter $objName
   if {$nested} {
      $PM_M set_L_composing_comets     $L_nested_comets
	  $PM_M set_handle_composing_comet $L_nested_handle
	  $PM_M set_handle_comet_daughters $L_nested_daughters [$PM_M get_composing_extension]
    }
   $PM_M Add_daughter $e $pos
  }
 set L $L_out_daughters
 this set_daughters {}
 this set_mothers   {}
 
# Manage parameters
 foreach {key val} [array get this PARAMS,*] {
   set key [string range $key 7 end]
   $e   Add_Params "$key $val"
   this Sub_Params $key
  }

   #puts "<${objName}::Comet_element::Substitute_by::set_daughters>\n  INFO $e :\n    daughters : [$e get_daughters]"
   $e Empty_out_daughter
   $e Add_daughters $L
   global debug
   if {$debug} {puts "  $e Add_daughters {$L}"}
   #puts "</${objName}::Comet_element::Substitute_by::set_daughters>"
 #puts "</${objName}::Comet_element::Substitute_by $e>"
}
#_________________________________________________________________________________________________________
Manage_CallbackList Comet_element Substitute_by end

#_________________________________________________________________________________________________________
method Comet_element Ensure_mothers_consistency {} {
 foreach m [this get_mothers] {
   $m Be_consistent_with_daughter $objName
  }
}
#_________________________________________________________________________________________________________
method Comet_element Be_consistent_with_daughter {d} {

}
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
method Comet_element get_unique_daughter_id {} {
 return [incr this(unique_CG_id)]
}
#_________________________________________________________________________________________________________
method Comet_element get_last_daughter_added {} {return $this(last_daughter_added)}

#_________________________________________________________________________________________________________
method Comet_element get_composing_extension {}  {return $this(composing_extension)}
method Comet_element set_composing_extension {e} {set this(composing_extension) $e}
#_________________________________________________________________________________________________________
#__________________________________ Hierarchy of the comets parts ________________________________________
#_________________________________________________________________________________________________________
method Comet_element get_mothers   {} {return $this(L_mothers)}
method Comet_element get_daughters {} {return $this(L_daughters)}
method Comet_element set_mothers   {v} {
 set L [this get_mothers]
 foreach m $L {$m Sub_daughter $objName}
 foreach m $v {$m Add_daughter $objName}
}

#_________________________________________________________________________________________________________
method Comet_element set_daughters {v} {
 set L [this get_daughters]
 foreach d $L {this Sub_daughter $d}
 foreach d $v {this Add_daughter $d}
}

#_________________________________________________________________________________________________________
method Comet_element get_out_mothers {} {return [this get_mothers]}

#_________________________________________________________________________________________________________
method Comet_element get_rec_L_nesting_element {} {
 set rep [this get_nesting_element]
 set L $rep
   foreach n $L {set rep [concat $rep [$n get_rec_L_nesting_element]]}
 return $rep
}

#_________________________________________________________________________________________________________
method Comet_element get_toplevel_nesting_PM {} {
 set PM_rep ""
 set rep [this get_nesting_element]
 if {$rep != ""} {
	 if {[lsearch [gmlObject info classes $rep] Physical_model] >= 0} {
	   set PM_rep [$rep get_toplevel_nesting_PM]
	  }
  }
  
 if {$PM_rep == "" && [lsearch [gmlObject info classes $objName] Physical_model] >= 0} {set PM_rep $objName}
 
 return $PM_rep
}

#_________________________________________________________________________________________________________
method Comet_element get_out_daughters { } {
 set L_rep {}
 set L_h_d [this get_handle_comet_daughters]
 if {$L_h_d == "" } {
   if {[llength [this get_handle_composing_comet]] == 0} {return [this get_daughters]} else {return {}}
  }
 foreach d $L_h_d {
   foreach n [$d get_out_daughters] {
     if {[lsearch [$n get_rec_L_nesting_element] $objName] == -1} {lappend L_rep $n}
    }
  }
 return $L_rep
}

#_________________________________________________________________________________________________________
method Comet_element get_nb_max_mothers {}    {return $this(nb_max_mothers)}
method Comet_element set_nb_max_mothers {n}   {set this(nb_max_mothers) $n}
method Comet_element get_nb_max_daughters {}  {return $this(nb_max_daughters)}
method Comet_element set_nb_max_daughters {n} {set this(nb_max_daughters) $n}

#_________________________________________________________________________________________________________
method Comet_element get_nb_daughters {} {return [llength [this get_out_daughters]]}

#_________________________________________________________________________________________________________
method Comet_element Has_for_nested_element {comet} {
 return [lsearch $this(L_composing_comets) $comet]
}

#_________________________________________________________________________________________________________
method Comet_element Has_for_daughter {e} {
 set pos 0
# set ext [this get_composing_extension]
 foreach d [this get_handle_comet_daughters] {
   if {[$d Has_for_daughter $e] != -1} {return $pos}
   incr pos
  }
 set plus [lsearch [this get_out_daughters] $e]
 if {$plus >= 0} {return [expr $pos + $plus]}

 return -1
}
#_________________________________________________________________________________________________________
method Comet_element Accept_more_mothers {}   {return [expr $this(nb_max_mothers)>[llength $this(L_mothers)]]}
#_________________________________________________________________________________________________________
method Comet_element Accept_more_daughters {} {return [expr $this(nb_max_daughters)>[llength $this(L_daughters)]]}
#_________________________________________________________________________________________________________
method Comet_element Add_mother    {m {index -1}} {
# Is this mother still present ?
 if {[lsearch $this(L_mothers) $m]!=-1} {return 2}
# Can we had one more mother ?
# if {[expr [this Accept_more_mothers] \
#        && [$m Accept_more_daughters]]} {} else {return 3}
 if {[this Accept_more_mothers]} {} else {return 3}
# Ok, let's had this mother
 if {[Add_element_quick this(L_mothers) $m]} {
   $m Add_daughter $objName $index
   return 1
  }
# If we arrive here, then we had a big problems...
 puts "$objName Add_mother $m $index :\n   BIG PROBLEME, insertion impossible in mothers list!!!"
 return 0
}
#_________________________________________________________________________________________________________
method Comet_element Sub_mother    {m} {global debug
									    if {$debug} {puts "$objName Comet_element::Sub_mother $m"}
								        set pos [lsearch $this(L_mothers) $m]
                                        if {[Sub_element this(L_mothers) $m]} {$m Sub_daughter $objName
                                                                               return 1}
                                       #puts "$objName Comet_element::Sub_mother $m => 0"
										return 0}

#_________________________________________________________________________________________________________
method Comet_element Add_nested_daughters {L_comets L_mother_handle L_daughter_handle ext} {
 this Add_composing_comet        $L_comets
 this Add_handle_composing_comet $L_mother_handle   0 $ext
 this Add_handle_comet_daughters $L_daughter_handle 0 $ext
# this Add_daughters              $L_mother_handle
}

#_________________________________________________________________________________________________________
method Comet_element Add_daughters {L_n {index -1}} {
 set pos $index
 foreach n $L_n {
   this Add_daughter $n $pos
   if {$index == -1} {} else {incr pos}
  }
}
#_________________________________________________________________________________________________________
method Comet_element Sub_daughters {L_n} {
 foreach n $L_n {
   this Sub_daughter $n
  }
}

#_________________________________________________________________________________________________________
method Comet_element Add_daughter    {m {index -1}} {
 if {[string equal $m $objName]} {return 4}
# Is this daughter still present ?
 if {[this Has_for_daughter $m] != -1} {return 2}
 if {[this Accept_more_daughters]} {} else {return 3}
# Ok, let's add this daughter
# Is this daughter part of the nested daughters ?
 set pos_nested [this Has_for_nested_element $m]
# If not, then it is marqued as a out-daughter.
 if {$pos_nested != -1} {
   set rep [Add_element this(L_daughters) $m $index]
   if {[expr $rep != 0]} {
     $m Add_mother $objName
     set this(last_daughter_added) $m
     return 1
    }
   set this(last_daughter_added) $m
   return $rep
  }
# Has m to be attached to a nested node of this object ?
# if \{[expr ($index != -1) && ([llength $this(L_handle_composing_daughters)] > $index)]\} \{
 if {[llength $this(L_handle_composing_daughters)] > $index} {
   if {$index == -1} {set i end} else {set i $index}
  } else {set i end}

      #
 if {[llength $this(L_handle_composing_daughters)] > 0 && ([lsearch [this get_handle_composing_comet] $m] == -1)} {
#   set node [lindex $this(L_handle_composing_daughters) $index]
   set node [lindex $this(L_handle_composing_daughters) $i]
   set this(last_daughter_added) $m
   set rep [$node Add_daughter $m]
   return $rep
  } else {
         #if {[llength [this get_handle_composing_comet]] > 0} {puts "$objName Comet_element::Add_daughter $m $index \n  => 0 : There is a nested handle but no information about composing daughters..."; return 0}
          set rep [Add_element this(L_daughters) $m $index]
          if {$rep != 0} {$m Add_mother $objName
                          set this(last_daughter_added) $m
                          return 1
                         }
          set this(last_daughter_added) $m
          return $rep
         }

 set this(last_daughter_added) $m
 return 1
}
#_________________________________________________________________________________________________________
method Comet_element Sub_daughter    {m} {set this(last_nested_daughter_subbing) {}
                                          if {[Sub_element this(L_daughters) $m]} {$m Sub_mother $objName
                                                                                   return 1
                                                                                  }
                                          foreach d $this(L_handle_composing_daughters) {
                                             if {[$d Sub_daughter $m]} {set this(last_nested_daughter_subbing)         $d
 																	    return 1
                                                                       }
                                           }
										  return 0
}

#_________________________________________________________________________________________________________
#______________________________________ Managing nesting _________________________________________________
#_________________________________________________________________________________________________________
method Comet_element get_composing_comets {}   {return $this(L_handle_composing_daughters)}
#_________________________________________________________________________________________________________
method Comet_element set_composing_comets {Lc} {
 foreach c $Lc {$c set_nesting_element $objName}
 set this(L_handle_composing_daughters) $Lc
 this Add_composing_comet $Lc
}
#_________________________________________________________________________________________________________
method Comet_element Add_composing_comet {Lc} {
 foreach c $Lc {$c set_nesting_element $objName}
 return [Add_list this(L_composing_comets) $Lc]
}
#_________________________________________________________________________________________________________
method Comet_element Sub_composing_comet {Lc} {
 foreach c $Lc {$c set_nesting_element {}}
 return [Sub_list this(L_composing_comets) $Lc]
}
Generate_accessors Comet_element L_composing_comets
#_________________________________________________________________________________________________________
method Comet_element get_handle_composing_comet { } {return $this(L_handle_composing_comets)}

#_________________________________________________________________________________________________________
method Comet_element set_handle_composing_comet {Lc {ext {}}} {
 set L {}
 this Sub_composing_comet $this(L_handle_composing_comets)
 foreach c $Lc {lappend L "$c$ext"; $c$ext set_nesting_element $objName; this Add_composing_comet $c$ext}
 set this(L_handle_composing_comets) $L
}

#_________________________________________________________________________________________________________
method Comet_element Add_handle_composing_comet {Lc index ext} {
 global debug
 set L {}
 foreach c $Lc {set n "$c$ext"
                lappend L $n
                $n set_nesting_element $objName
                this Add_daughter        $n
				this Add_composing_comet $n
               }
 set rep [Add_list this(L_handle_composing_comets) $L]
 return $rep
}
#_________________________________________________________________________________________________________
method Comet_element Sub_handle_composing_comet {Lc {ext {}}} {
 set L [list]
 foreach c $Lc {set n "$c$ext"
                $n set_nesting_element {}
				lappend L $n
			    this Sub_composing_comet $n
				  Sub_element this(L_handle_composing_comets) $n
                this Sub_daughter        $n
			   }
 # DEBUG set rep [Sub_list this(L_handle_composing_comets) $L]
   set rep 1
 # /DEBUG
 if {[expr $rep >= 1]} {foreach c $Lc {$c Sub_EE_successor [this get_Handle_EE]}
                       }
 return $rep
}
#_________________________________________________________________________________________________________
method Comet_element get_handle_comet_daughters {} {return $this(L_handle_composing_daughters)}
#_________________________________________________________________________________________________________
method Comet_element set_handle_comet_daughters {Lc ext} {
 set L {}
 this Sub_composing_comet $this(L_handle_composing_daughters)
 foreach c $Lc {lappend L "$c$ext"; $c$ext set_nesting_element $objName; this Add_composing_comet $c$ext}
 set this(L_handle_composing_daughters) $L
}
#_________________________________________________________________________________________________________
method Comet_element Add_handle_comet_daughters {Lc index ext} {
 set L {}
 foreach c $Lc {lappend L "$c$ext"; $c$ext set_nesting_element $objName; this Add_composing_comet $c$ext}

 return [Add_list this(L_handle_composing_daughters) $L $index]
}
#_________________________________________________________________________________________________________
method Comet_element Sub_handle_comet_daughters {Lc {ext {}}} {
 set L {}
 foreach c $Lc {lappend L "$c$ext"; $c$ext set_nesting_element {}; this Sub_composing_comet $c$ext}
 return [Sub_list this(L_handle_composing_daughters) $L]
}

#_________________________________________________________________________________________________________
method Comet_element get_objName {} {return $objName}

#_________________________________________________________________________________________________________
method Comet_element get_name {}   {return $this(name)}
method Comet_element set_name {n}  {set this(name) $n; return $n}

#_________________________________________________________________________________________________________
method Comet_element get_descr {}  {return $this(descr)}
method Comet_element set_descr {d} {set this(descr) $d; return $d}

#_________________________________________________________________________________________________________
method Comet_element get_Common_FC {}   {return $this(FC)}
method Comet_element set_Common_FC {fc} {set this(FC) $fc
                                         return $fc}

#_________________________________________________________________________________________________________
method Comet_element get_propagate_next_liste_cmd {}   {return $this(propagate_next_liste_cmd)}
method Comet_element set_propagate_next_liste_cmd {n}  {set this(propagate_next_liste_cmd) $n; return $n}
#_________________________________________________________________________________________________________
method Comet_element get_propagate_prev_liste_cmd {}   {return $this(propagate_prev_liste_cmd)}
method Comet_element set_propagate_prev_liste_cmd {n}  {set this(propagate_prev_liste_cmd) $n; return $n}

#_________________________________________________________________________________________________________
method Comet_element get_is_propagating {} {return $this(is_propagating)}
#_________________________________________________________________________________________________________
method Comet_element Propagate_excusive {cmd {where 3}} {
global debug
 if {$debug} {puts "$objName Propagate $cmd $where"}
 if {$this(is_propagating)} {
   if {$debug} {puts "  !!!Still propagating"}
   return 0
  }
 set this(is_propagating) 1
   if {[expr "$where & 1"]} {set L [eval $this(propagate_prev_liste_cmd)]
                             foreach obj $L {$obj Propagate $cmd $where}
                            }
   if {[expr "$where & 2"]} {set L [eval $this(propagate_next_liste_cmd)]
                             foreach obj $L {$obj Propagate $cmd $where}
                            }

   set this(is_propagating) 0
 return 1
}

#_________________________________________________________________________________________________________
method Comet_element Propagate {cmd {where 3}} {
global debug
 if {$debug} {puts "$objName Propagate $cmd $where"}
 if {$this(is_propagating)} {
   if {$debug} {puts "  !!!Still propagating"}
   return 0
  }
 set this(is_propagating) 1
   if { [catch {eval "this $cmd"} err] } {
     puts "PROPAGATION ERROR : The following command generated an error:\n  \"$objName $cmd\"\n  ERROR GENERATED : $err"}
   if {[expr "$where & 1"]} {set L [eval $this(propagate_prev_liste_cmd)]
                             foreach obj $L {$obj Propagate $cmd $where}
                            }
   if {[expr "$where & 2"]} {set L [eval $this(propagate_next_liste_cmd)]
                             foreach obj $L {$obj Propagate $cmd $where}
                            }

   set this(is_propagating) 0
 return 1
}

#__________________________________ Managing the Evolutions engines_______________________________________
#_________________________________________________________________________________________________________
method Comet_element Add_EE {EE} {return [Add_element this(L_E_engine) $EE]}
method Comet_element Sub_EE {EE} {return [Sub_element this(L_E_engine) $EE]}
#_________________________________________________________________________________________________________
method Comet_element get_Handle_EE {}   {return $this(handle_EE)}
method Comet_element set_Handle_EE {EE} {set this(handle_EE) $EE; return $EE}
#_________________________________________________________________________________________________________
method Comet_element Add_EE_successor {EE} {}
#_________________________________________________________________________________________________________
method Comet_element Sub_EE_successor {EE} {}

#_________________________________________________________________________________________________________
#________________________________________Common functionnal core__________________________________________
#_________________________________________________________________________________________________________
method CommonFC constructor {} {
# Can be UnDone, InProgress, Done
 set this(state)            Undone
}

#_________________________________________________________________________________________________________
method CommonFC get_state {}             {return $this(state)}
method CommonFC set_state {v}            {set this(state) $v; return $v}

#_________________________________________________________________________________________________________
method CommonFC Is_validated {} {return 1}

#_________________________________________________________________________________________________________
#___________________________________________Logical consistency___________________________________________
#_________________________________________________________________________________________________________
inherit Logical_consistency Comet_element
method Logical_consistency constructor {name descr args} {
 this inherited $name $descr
# A list of logical models (can be presentation, interaction, functionnal core...)
 set this(L_LM)       [list]
 set this(FC)          {}

 this set_propagate_next_liste_cmd "this get_L_LM"

 this Is_a_concept 0
 this Is_a_task    1
 this Is_an_op     1
 set this(cmd_is_task_completed) "Evaluate_task_completion_defaut $objName"
 set this(is_task_completed)     1
 
 eval "$objName configure $args"
}

#_________________________________________________________________________________________________________
Generate_accessors Logical_consistency [list cmd_is_task_completed]

#_________________________________________________________________________________________________________
proc Evaluate_task_completion_defaut {LC} {
 foreach d [$LC get_out_daughters] {
   if {![$d Is_Task_completed]} {return 0}
  }
 return 1
}


#_________________________________________________________________________________________________________
method Logical_consistency Is_Task_completed {} {
 return $this(is_task_completed)
}

#_________________________________________________________________________________________________________
method Logical_consistency Propagate_task_completed_info {} {
 foreach m [this get_mothers] {
   $m Evaluate_if_task_is_completed
  }
} 

#_________________________________________________________________________________________________________
Manage_CallbackList Logical_consistency Propagate_task_completed_info begin

#_________________________________________________________________________________________________________
method Logical_consistency Evaluate_if_task_is_completed {} {
 set prev [this Is_Task_completed]
 set this(is_task_completed) [eval $this(cmd_is_task_completed)]
 if {$prev != $this(is_task_completed)} {this Propagate_task_completed_info}
 return $this(is_task_completed)
} 

#_________________________________________________________________________________________________________
method Logical_consistency Task_is_completed {} {
 if {[[this get_Common_FC] Is_validated]} {
   # INSERT CALLBACKS HERE
   return 1
  }
 return 0
}

#_________________________________________________________________________________________________________
Manage_CallbackList Logical_consistency [list Task_is_completed] insert

#_________________________________________________________________________________________________________
method Logical_consistency dispose {} {
 foreach C [this get_mothers]   {$C   Sub_daughters_R $objName}
 foreach C [this get_daughters] {this Sub_daughters_R $C}
  
 set L [this get_L_LM]
 foreach lm $L {$lm dispose}
 if {[string equal $this(FC) {}]} {} else {$this(FC) dispose}
 this inherited
}

#_________________________________________________________________________________________________________
method Logical_consistency Style {LM args} {
 return [$objName$LM Style $args]
}

#_________________________________________________________________________________________________________
method Logical_consistency get_LC {}   {return $objName}

#_________________________________________________________________________________________________________
method Logical_consistency Add_daughters_R {L_n {index -1}} {
 set pos $index
 foreach n $L_n {
   this Add_daughter_R $n $pos
   if {$index != -1} {incr pos}
  }
}
#_________________________________________________________________________________________________________
method Logical_consistency Sub_daughters_R {L_n} {
 foreach n $L_n {
   this Sub_daughter_R $n
  }
}
#_________________________________________________________________________________________________________
# Check if m is a comet element, create a CometText elsewhere
method Logical_consistency Add_daughter  {m {index -1}} {
 set still_exists 0
 if {[gmlObject info exists object $m]} {
#   set L [eval gmlObject info classes [gmlObject info classofobject $m]]
   set L [eval gmlObject info classes $m]
   set position [lsearch $L Logical_consistency]
   if {$position >= 0} {set still_exists 1}
  }
 if {[expr $still_exists == 0]} {
   set name_new_comet "CG_${objName}_$this(unique_CG_id)"
   incr this(unique_CG_id)
   CometText $name_new_comet $m {Comet generated on the fly}
     $name_new_comet set_text $m
   return [this Add_daughter $name_new_comet $index]
  }

 return [this inherited $m $index]
}

#_________________________________________________________________________________________________________
method Logical_consistency Add_daughter_R_of {c {index -1}} {
 set pos $index
 foreach n $L_n {
   this Add_daughter_R_of $n $pos
   if {$index == -1} {} else {incr pos}
  }
}
#_________________________________________________________________________________________________________
method Logical_consistency Add_daughter_R_of {c {index -1}} {
 set pos $index
 foreach d [$c get_daughters] {
   this Add_daughter_R $d $pos
   if {[expr $index == -1]} {} else {incr pos}
  }
 if {[expr $index == -1]} {set index 0}
 $c Subscribe_to_Add_daughter_R $objName "upvar m comet; upvar index index_de_ref; $objName Add_daughter_R \$comet \[expr $index + \$index_de_ref\]"
 $c Subscribe_to_Sub_daughter_R $objName "upvar m comet; $objName Sub_daughter_R \$comet"
}

#_________________________________________________________________________________________________________
method Logical_consistency Add_daughter_R {m {index -1}} {
 set res [this Add_daughter $m $index]
 if {[expr $res == 0]} {return $res}
 if {$res==1} {
   set m [this get_last_daughter_added]
   ${objName}_LM_LP Add_daughter ${m}_LM_LP $index
   set LM  [${objName}_LM_LP get_LM_to_connect_daughters]
   set LMD [$LM get_last_daughter_added]
   $LM Connect_PM_descendants {} $LMD
  }

# INSERT CALLBACKS HERE
 return $res
}

#_________________________________________________________________________________________________________
# Prendre garde aux comets nestes dans cette affaire....notamment en ce qui va concerner les entrelacements
method Logical_consistency Sub_daughter_R {m} {
 set res [this Sub_daughter $m]
 if {[expr $res == 1]} {
# # Don't forget to consider the case where the LM is nested
   set L_LM [this get_L_LM]
   set L_LMD [$m get_L_LM]
   foreach LM $L_LM {
     foreach LMD $L_LMD {
       if {[$LM Has_for_daughter $LMD] != -1} {
         $LM Sub_daughter $LMD
        }
      }
    }
  }

# INSERT CALLBACKS HERE
 return $res
}

#_________________________________________________________________________________________________________
Manage_CallbackList Logical_consistency Add_daughter_R end res
Manage_CallbackList Logical_consistency Sub_daughter_R end res

#_________________________________________________________________________________________________________
method Logical_consistency set_mothers_R {Lc} {
 set L [this get_mothers]
 foreach m $L  {
   $m Sub_daughter_R $objName
  }
 foreach m $Lc {
   $m Add_daughter_R $objName
  }
}

#_________________________________________________________________________________________________________
method Logical_consistency set_daughters_R {v} {
 set L [this get_daughters]
 foreach d $L {this Sub_daughter_R $d}
 foreach d $v {this Add_daughter_R $d}
}

#_________________________________________________________________________________________________________
method Logical_consistency Add_mother    {m {index -1}} {set rep [this inherited $m $index]
                                                         if {[expr $rep == 1]} {this Add_EE_successor [$m get_Handle_EE]
#                                                                                #$m Connect_LM_descendants _LM_LP
                                                                               }
                                                         return $rep
                                                        }
method Logical_consistency Sub_mother    {m} {set rep [this inherited $m]
                                              if {$rep == 1} {this Sub_EE_successor [$m get_Handle_EE]}
                                              return $rep
                                             }

#_________________________________________________________________________________________________________
method Logical_consistency set_Common_FC {fc} {this inherited $fc
                                               foreach LM [this get_L_LM] {$LM set_Common_FC $fc}
                                              }

#____________________________________ Managing the Logicals Models________________________________________
#_________________________________________________________________________________________________________
method Logical_consistency get_L_LM {} {return $this(L_LM)}
method Logical_consistency Add_LM {LM} {if {[Add_element this(L_LM) $LM]} {
                                          $LM set_LC $objName
                                          $LM set_Common_FC $this(FC)
                                          $LM Add_EE_successor [this get_Handle_EE]
                                          return 1
                                         }
                                        return 0
                                       }
method Logical_consistency Sub_LM {LM} {if {[Sub_element this(L_LM) $LM]} {
                                           $LM set_LC {}
                                           $LM Sub_EE_successor [this get_Handle_EE]
                                          }
                                       }
#_________________________________________________________________________________________________________
method Logical_consistency Connect_LM_descendants {suffixe {dec " "}} {
global debug
 set LM "$objName$suffixe"
 foreach LCD [this get_out_daughters] {
   set rep [$LM Add_daughter "$LCD$suffixe"]
   if {[expr $rep == 1 || $rep == 2]} {
     $LCD Connect_LM_descendants $suffixe "$dec| "
    } else {if {$debug} {puts "$dec| -> ERROR: $rep"}}
  }
}

#_______________________________ Managing the task or concept state_______________________________________
#_________________________________________________________________________________________________________
method Logical_consistency Is_a_concept {{v nop}} {if {[string equal $v nop]} {return $this(is_a_concept)} else {set this(is_a_concept) $v}}
method Logical_consistency Is_a_task    {{v nop}} {if {[string equal $v nop]} {return $this(is_a_task)   } else {set this(is_a_task) $v}}
method Logical_consistency Is_an_op     {{v nop}} {if {[string equal $v nop]} {return $this(is_an_op)    } else {set this(is_an_op) $v}}

#_______________________________ Managing the common Functionnal Core_____________________________________
#_________________________________________________________________________________________________________
method Logical_consistency get_state {}             {return [$this(FC) get_state]}
method Logical_consistency set_state {v}            {$this(FC) set_state $v; return $v}
method Logical_consistency get_fct_is_validable {}  {return [$this(FC) get_fct_is_validable]}
method Logical_consistency set_fct_is_validable {v} {$this(FC) set_fct_is_validable $v; return $v}

#_________________________________________________________________________________________________________
#____________________________________________ Logical model_______________________________________________
#_________________________________________________________________________________________________________
inherit Logical_model Comet_element
method Logical_model constructor {name descr args} {
 this inherited $name $descr

# A list of physical models (can be presentation, interaction, functionnal core...)
 set this(L_PM)         [list]
 set this(L_actives_PM) [list]

 set this(LC) {}
 set this(FC) {}

 set this(unique_PM_id) 0

 this set_propagate_prev_liste_cmd "this get_LC"
 this set_propagate_next_liste_cmd "this get_L_actives_PM"

 set this(L_PM_factories) [list]
 set this(LM_to_connect_daughters) $objName

# COMET/RE
 set this(COMET_RE,constructor) 1
 set this(COMET_RE_state,constructor) {}

# Evaluation du reste du constructeur
 eval "$objName configure $args"
}

#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
method Logical_model do_exists_COMET_RE_expr {mtd} {return [info exists this(COMET_RE,$mtd)]}
method Logical_model get_COMET_RE_expr {mtd} {if {[info exists this(COMET_RE,$mtd)]} {return $this(COMET_RE,$mtd)} else {return {E(*)}}}
method Logical_model set_COMET_RE_expr {m v} {set this(COMET_RE,$m) $v}

method Logical_model get_COMET_RE_state {mtd} {if {[info exists this(COMET_RE_state,$mtd)]} {return $this(COMET_RE_state,$mtd)} else {return {}}}
method Logical_model set_COMET_RE_state {mtd v} {set this(COMET_RE_state,$mtd) $v}

#_________________________________________________________________________________________________________
method Logical_model get_nesting_element {} {
 set rep [this inherited]
 if {[string equal $rep ""]} {
   set LC [this get_LC]
   if {![string equal $LC ""]} {return [$LC get_nesting_element]}
  }
 return $rep
}

#_________________________________________________________________________________________________________
method Logical_model Add_COMET_RE_event {mtd evt} {
 set evt [list [clock clicks -millisecond] $evt]
 if {[info exists this(COMET_RE_state,$mtd)]} {
   lappend this(COMET_RE_state,$mtd) $evt
  } else {set this(COMET_RE_state,$mtd) [list $evt]}
}

#_________________________________________________________________________________________________________
# Etat : {<TPS, ACTION>}
method Logical_model Eval_COMET_RE {mtd} {
 if {![info exists this(COMET_RE_state,$mtd)]} {return 0}
 set tps [clock clicks -millisecond]
# Vider les tats prims
 set n_state {}
 set tps_min [expr $tps - 20000]
 foreach evt $this(COMET_RE_state,$mtd) {
   if {[lindex $evt 0] > $tps_min} {lappend n_state $evt}
  }
 set this(COMET_RE_state,$mtd) $n_state
# Evaluer
 set expr_RE $this(COMET_RE,$mtd)
 #puts "Evaluation COMET/RE avec :\n    LM : $objName\n  EXPR : $expr_RE\n  STAT : $n_state"
 return [Eval_COMET_RE $objName $tps expr_RE n_state]
}

#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
method Logical_model set_Common_FC {fc} {this inherited $fc
                                         foreach PM [this get_L_PM] {$PM set_Common_FC $fc}
                                        }

#_________________________________________________________________________________________________________
method Logical_model dispose {} {
 set LC [this get_LC]
 if {[string equal $LC {}]} {} else {$LC Sub_LM $objName}

 foreach PM [this get_L_PM]         {$PM dispose}
   set this(L_PM)         {}
   set this(L_actives_PM) {}
# foreach f  [this get_PM_factories] {$f  dispose}
#   set this(L_PM_factories) {}

 this inherited
}

#_________________________________________________________________________________________________________
#__________________________________________________ Styles________________________________________________
#_________________________________________________________________________________________________________
proc Read_file_as_css++ {f_name} {
 if {[file exists $f_name]} {
   set f [open $f_name]; set str [read $f]; close $f
   return [Read_string_as_css++ $str] 
  } else {return ""}
}

#_________________________________________________________________________________________________________
proc Read_string_as_css++ {str} {
 set L_rep ""
 set L [split $str "\n"]
 set i 0; set length [llength $L]
 while {$i < $length} {
   set line [lindex $L $i]
   if {[regexp "^(.*) *\{ *$" $line reco sel]} {
     set rule ""
	 incr i; set line [lindex $L $i]
	 while {![regexp "^ *\} *$" $line] && $i<$length} {
	   append rule $line "\n"
	   incr i; set line [lindex $L $i]
	  }
	 lappend L_rep [list $sel $rule]
    }
   incr i
  }
 return $L_rep
}

#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
proc Apply_style_on {L_C L_mapping GDD_op_file CSS_file} {
 if {[file exists $GDD_op_file]} {
   set f [open $GDD_op_file r]; set GDD_op [read $f]; close $f
  } else {set GDD_op ""}
 set CSS    [Read_file_as_css++ $CSS_file]
 foreach C $L_C {
   Update_style [$C get_DSL_GDD_QUERY] [$C get_styler] $GDD_op $CSS $C $L_mapping
  }
}

#_________________________________________________________________________________________________________
proc Update_style {dsl_q dsl_css str_fct str_style current {L_mapping ""} {L_rep ""}} {
 #puts "Update_style\n  - dsl_q   : $dsl_q\n  - dsl_css : $dsl_css\n  - fct : $str_fct\n  - rules : $str_style\n  - current = $current\n  - L_mapping : $L_mapping"
# Process all the functions to give a list <fct_name, expr>
 set letter {[a-zA-Z0-9_\$"{}]}
 set space  "\[ \n\]"
 set L_str_fct [split $str_fct "\;"]
 set L_fct {}
 foreach str_fct $L_str_fct {
   if {[regexp "^$space*($letter+)$space*:$space*(.*)$space*\$" $str_fct reco name exp]} {
     lappend L_fct [list $name $exp]
    }
  }

# Let's see if some CSS rules have GDD access
 if {$L_rep == ""} {set do_css 1} else {set do_css 0}
 foreach r $str_style {
   if {[llength $r] == 2} {
     #puts "Cas rgle simple"
	 set root [lindex [gmlObject info objects CometRoot] 0]
	 set L_ops [split [lindex $r 1] "\;"]
	} else {
	        #puts "Cas rgle complexe, avec racine spcifie:\n$r"
	        set root  [lindex $r 1];
	        set L_ops [split [lindex $r 2] "\;"]
	       }
   
   # Mapping of variables names
#   set L_ops          [string map $L_mapping      $L_ops]
   set L_real_mapping [concat     $L_mapping      [list {$current} $current]]
   set sel_svg        [string map $L_real_mapping [lindex $r 0]]
   set L_ops          [string map $L_real_mapping $L_ops]
   
   if {$do_css} {
	 set L_rep [CSS++ $root $sel_svg]
	}
   #puts "_________Traitement de \"$r\"\n  - sel : $sel_svg\n  - res : $L_rep"
   foreach op $L_ops {
     set val {}
     #set sel $sel_svg
     set Req_type {}
     #puts "__OP \"$op\""
     if {[regexp "^\[ \\n\]*GDD_type\[ \\n\]*:\[ \\n\]*(.*)$" $op reco val]} {} else {
       if {[regexp "^$space*GDD_fct$space*:$space*($letter+)$space*\\($space*(.*)$space*\\)$space*\$" $op reco fct_name params]} {
         #puts "Trouv un appel  une fonction GDD...on la traduit en expression de parcours"
         foreach fct $L_fct {if {[string equal [lindex $fct 0] $fct_name]} {
                               set val "? : $params : [lindex $fct 1]"
                               set Req_type GDD
                               break
                              }
                            }
        } else {
            if {[regexp "^$space*FCT_($letter+)$space*:$space*(.*)$space*\$" $op reco fct_name val]} {
              set Req_type FCT
             } else {if {[regexp "^$space*ECA$space*:$space*(.*)$space*\$" $op reco ECA_rule]} {
                       set Req_type ECA
                      } else {
					          #if {![regexp "^\[ \n\]*\$" $op]} {}
                             }
                    }
           }
      }
     switch $Req_type {
       GDD {
            if {[llength $L_rep]==0} {continue}
            #puts "QUERY ON GDD :\n  sel  : $sel\n  query : $val\n   -----"
            if {[catch {$dsl_q QUERY $val} res]} {puts "ERROR in style query ($dsl_q QUERY $val):\n$res\n    _____"} else {
              set L_nodes {}
              foreach n [$dsl_q get_Result] {
                Add_list L_nodes [lindex $n 1]
               }
           # Charger les factories, dcharger les modles prcdents...
           #puts "for \"$L_rep\" we can plug $L_nodes"
              set new_L_rep ""
			  foreach n $L_rep {
                if {[catch "set new_n \[$n Update_factories \{$L_nodes\}\]" res]} {
				  puts "STYLE ERROR ($n Update_factories \{$L_nodes\}):\n$res"
				  lappend new_L_rep $n
				 } else {if {$new_n != ""} {
				           lappend new_L_rep $new_n
						   if {$n == $current} {set current $new_n}
						  }
				        }
               }
			#set L_rep [CSS++ $root $sel_svg]
			set L_rep $new_L_rep
           }}
       FCT {
            foreach n $L_rep {
              #puts "  FCT eval of \"$n $fct_name $val\""
			  set core_PM ""; if {[[$n get_LC] Has_MetaData Core_of_PM]} {set core_PM [[$n get_LC] Val_MetaData Core_of_PM]}
			  set val_txt [string map [list {---} " \n "] $val]
			  set OK 1
              if {[catch "set obj $n; $n $fct_name {$val_txt}" res]} {
				if {[catch "set obj $n; $n $fct_name $val_txt" res]} {
				  puts "FCT STYLE ERROR ($n $fct_name {$val_txt});\n  => $res\n  => L_rep was {$L_rep}"
				  puts "FCT STYLE ERROR ($n $fct_name $val_txt);\n  => $res\n  => L_rep was {$L_rep}"
				  set OK 0
				 }
               }
			  if {$OK} {
			    # Case when the element has been encapsulated
				if {[[$n get_LC] Has_MetaData Core_of_PM]} {
				  set new_core_PM [[$n get_LC] Val_MetaData Core_of_PM]
				  #puts "---     core : $core_PM\n--- new_core : $new_core_PM"
				  if {$n == $current && $new_core_PM != $core_PM} {
				    set current $new_core_PM
				   }
                 }
			   }
             }
           }
       ECA {
            if {[llength $L_rep] > 0} {
              set n [lindex $L_rep 0]
              if {[catch "[$n get_DSL_ECA] Interprets \{$ECA_rule\} \{$L_rep\}" res]} {
                puts "ECA ERROR ([$n get_DSL_ECA] Interprets \{$ECA_rule\});\n$res"
               }
             }
           }
      }
	 continue 
     if {[string equal $Req_type GDD]} {
       #puts "Trouv une requte GDD : \n  * $val"
      # Lets' see which comets are concerned...
#       set L_rep {}
#       Style_CSSpp DSL_SELECTOR sel L_rep $root 1
#       if {[llength $L_rep]==0} {continue}
       if {[catch {$dsl_q QUERY $val} res]} {puts "ERROR in style query (dsl: $dsl_q):\n$res"} else {
         #puts "query : \"$val\"\n  [$dsl_q get_Result]"
         #puts "  $L_rep"
         set L_nodes {}
         foreach n [$dsl_q get_Result] {
           Add_list L_nodes [lindex $n 1]
          }
         # Charger les factories, dcharger les modles prcdents...
         #puts "for \"[lindex $r 1]\" we can plug $L_nodes"
         foreach n $L_rep {
           $n Update_factories $L_nodes
          }
        }
      }
    }
  }
}

#_________________________________________________________________________________________________________
method Logical_consistency Update_factories {L_nodes} {
 return [${objName}_LM_LP Update_factories $L_nodes]
}

#_________________________________________________________________________________________________________
# XXX PB POTENTIEL ICI
method Logical_model Update_factories {L_nodes} {
 #puts "$objName Update_factories \{$L_nodes\}"
 # Retrieve factories from nodes list
 set L_factories {}
 foreach node $L_nodes {
   Add_list L_factories [$node get_L_factories]
  }

 # Update factories
 this set_PM_factories {}
 foreach n $L_nodes {
   set L_f [$n get_L_factories]
   foreach f $L_f {
     this Add_PM_factories [Generate_factories_for_PM_type [list "$f [$n get_ptf]"] $objName]
    }
  }

 # Remove and plug existing PMs if neccessary
 set L_prev_PM [this get_L_PM]
 foreach PM $L_prev_PM {
   set is_right 0
     foreach f $L_factories {
	   if {[$PM Has_for_style $f]} {set is_right 1; break}
	  }
   if {$is_right == 0}      {$PM Substitute_by_PM_factory [this get_PM_factories]
                             $PM dispose
                            }
  }

 return $objName
}

#_________________________________________________________________________________________________________
method Physical_model Update_factories {L_nodes} {
 #puts "$objName Update_factories \{$L_nodes\}"
 # Retrieve factories from nodes list
 # Not all factories are convenient for this PM, we have to filtred
 set L_factories {}
 foreach node $L_nodes {
   set ptf [$node get_ptf]
   if {[string equal $ptf *] || [string equal ${objName}_cou_ptf *]} {
     Add_list L_factories [$node get_L_factories]
    } else {if {[$ptf Accept_for_daughter ${objName}_cou_ptf]} {Add_list L_factories [$node get_L_factories]}
           }
  }

 if {[llength $L_factories]==0} {puts "_-_-_- There is no factory for {$L_nodes}"; return $objName}
 foreach f $L_factories {
   if {[this Has_for_style $f]} {return $objName}
  }
 # DEBUG set inter [Liste_Intersection $L_factories [gmlObject info classes $objName]]
 # DEBUG if {[llength $inter]>0} {return $objName}

 set c [lindex $L_factories 0]
 set LM [this get_LM]
 # Check wether an existing inactive PM fit at least one factories 
 set name {}
 set LM [this get_LM]
 foreach PM [$LM get_L_inactives_PM] {
   foreach f $L_factories {
     if {[$PM Has_for_style $f]} {set name $PM}
    }
   if {![string equal $name ""]} {break}
  }

 # Elsewhere create a new one
 if {[string equal $name {}]} {
   set name "[this get_LC]_PM_P_[$LM get_a_unique_id]"
   $c $name "A $c for [this get_LC]" {Automatically generated by styling process}
  }

   $LM Substitute $objName $name
   $LM set_PM_inactive $objName
 return $name
}

#_________________________________________________________________________________________________________
method Physical_model Substitute_by_PM_factory {L_PM_f} {
#puts "$objName Physical_model::Substitute_by_PM_factory {$L_PM_f}"
 set LM [this get_LM]
# Chercher d'abord dans les PM non actifs !!! et rendre inactif une fois substitu !!!!
 foreach i_PM [$LM get_L_inactives_PM] {
   foreach PM_f $L_PM_f {
     if {[$PM_f Is_compatible_with_ptf [${i_PM}_cou get_ptf]]} {
	   this Substitute_by $i_PM
	   $LM set_PM_inactive $objName
	   return {}
	  }
	} 
  }
 foreach PM_f $L_PM_f {
   if {[$PM_f Is_compatible_with_ptf [${objName}_cou get_ptf]]} {
     set name "[this get_LC]_PM_P_[$LM get_a_unique_id]"
     set c [lindex [$PM_f get_classes] 0]
     $c $name "A $c for [this get_LC]" {Automatically generated by styling process}
     this Substitute_by $name
	 $LM set_PM_inactive $objName
     return $name
    }
  }
 return {}
}

#_________________________________________________________________________________________________________
# XXX TODO
# Trouver un bon systme pour ne pas r appliquer des transfo indfiniment
# Trouver un systme pour faire de l'encapsulation vraiment automatique, en gnrant les mthodes de l'API smantique
proc CSS++_Encapsulate {C_element selector str_DSL} {
 if {[$C_element exists_Var CSS++_Encapsulate]} {
   if {[string equal [$C_element get_Var CSS++_Encapsulate] $selector]} {return}
  }

 set L_classes    [gmlObject info classes $C_element]
 set class        [lindex $L_classes 0]
 set encaps_class U_encaps_$class

# Check if a right class still exist or not, create it in the later case
 if {![gmlObject info exists class $encaps_class]} {
   #TODO
   # Use : gmlObject info interface  sur le Common FC
   set CFC [$C_element get_Common_FC]
   set L_interfaces [gmlObject info interface $CFC]
   set L_interfaces [string map ]
  }

# Encapsulate with the right class, depending whether it is a PM or a LM
 if {[lsearch $L_classes Logical_model] >= 0} {
   # Check if the PM universal class do exist, create it if not
   set encaps_class_PM U_PM_for_$encaps_class
   if {![gmlObject info exists class $encaps_class_PM]} {
     #TODO
    }
   # Encapsulate
   Encapsulate $C_element $encaps_class_PM $encaps_class
  }

 if {[lsearch $L_classes Physical_model] >= 0} {
  #Encapsulate $C_element
  }

}

#_________________________________________________________________________________________________________
#____________________________________________ Factories __________________________________________________
#_________________________________________________________________________________________________________
#source PM_factory.tcl

Generate_List_accessor Logical_model L_PM_factories PM_factories
Generate_List_accessor Logical_model L_actives_PM   L_actives_PM
Generate_List_accessor Logical_model L_PM           L_PM
Generate_accessors Logical_model LM_to_connect_daughters

#_________________________________________________________________________________________________________
method Logical_model set_PM_factories_from_GDD {req} {
 if {[regexp {^ *(.*)\((.*)\) *$} $req reco fct p]} {
   set req "$fct $p"
  }
 eval "C_GDD $objName $req"
}

#_________________________________________________________________________________________________________
method Logical_model get_L_compatible_factories_with_ptf_in {ptf L_f_name} {
 upvar $L_f_name L_f

 set rep [list]
 foreach f $L_f {
   if {[$f Is_compatible_with_ptf $ptf]} {lappend rep $f}
  }
 return $rep
}

#_________________________________________________________________________________________________________
method Logical_model get_L_compatible_factories_with_ptf {ptf} {
 return [this get_L_compatible_factories_with_ptf_in $ptf this(L_PM_factories)]
}

#_________________________________________________________________________________________________________
method Logical_model get_L_compatible_factories_with_type {type} {
 set rep {}
 foreach f [this get_PM_factories] {
   if {[$f Is_compatible_with_type $type]} {lappend rep $f}
  }
 return $rep
}

#_________________________________________________________________________________________________________
#______________________________________ Style related methods ____________________________________________
#_________________________________________________________________________________________________________
# L_ptf_type : [list "TK Specifyer_PM_P_text_TK"]
#_________________________________________________________________________________________________________
method Logical_model Has_for_style {s} {
 if {[this inherited $s]} {return 1}
 if {$s == ""} {set s "{}"}
 return [eval [this get_LC] Has_for_style $s]
}

#_________________________________________________________________________________________________________
method Logical_model Ptf_style {L_ptf_type} {

 foreach ptf_type $L_ptf_type {
   # Get the PMs matching the ptf
   set ptf  [lindex $ptf_type 0]
   set type [lindex $ptf_type 1]
   set L_PMs {}
   foreach PM [this get_L_actives_PM] {
     if {[$ptf Accept_for_daughter ${PM}_cou_ptf]} {
       lappend L_PMs $PM
      }
    }
   # Replace them by new type
   set L_PM_to_do {}
   foreach PM $L_PMs {
     # Do we have a pre existing PM corresponding to type?
     if {[$PM Has_for_styles $type]} {continue}
     set done 0
     foreach pre_PM [this get_L_PM] {
       if { [$pre_PM Accept_more_mothers] } {
         if {[$pre_PM Has_for_styles $type]} {
           this Substitute $PM $pre_PM
           set done 1
          }
        }
      }
     if {$done} {} else {lappend L_PM_to_do $PM}
    }

   # else...
   if {[llength $L_PM_to_do]==0} {continue}
   set L_f [this get_L_compatible_factories_with_type $type]
   foreach PM $L_PM_to_do {
     set L_f_ptf [this get_L_compatible_factories_with_ptf_in $ptf L_f]
     set f [lindex $L_f_ptf 0]
     if {[string equal $f {}]} {continue}
       set new_PM [$f Generate [this get_LC] $objName]
       this Substitute $PM $new_PM
    }
  }
}

#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
method Logical_model set_Common_FC {fc} {this inherited $fc
                                         foreach PM [this get_L_PM] {$PM set_Common_FC $fc}
                                        }
#_________________________________________________________________________________________________________
#_______________________________ Managing the common Functionnal Core_____________________________________
#_________________________________________________________________________________________________________
method Logical_model get_FC {}   {return $this(FC)}
method Logical_model set_FC {fc} {set this(FC) $fc; return $fc}
#_________________________________________________________________________________________________________
method Logical_model get_LC {}   {return $this(LC)}
method Logical_model set_LC {lc} {set this(LC) $lc;
                                  if {[string equal $lc {}]} {return {}}
                                  set this(FC) [$this(LC) get_Common_FC]
                                  set this(names_obj) [list $objName $lc]
                                  set this(base_classes) [concat [gmlObject info classes $lc] [gmlObject info classes $objName]]
                                  foreach PM [this get_L_PM] {$PM set_LM $objName}
                                  return $lc
                                 }
#_________________________________________________________________________________________________________
method Logical_model Sub_daughter {m} {
 set res [this inherited $m]
 if {[expr $res == 1]} {
# # Let's deconnect all PMs who only have for mothers PMs from $m
   foreach PM [$m get_L_actives_PM] {
     set L_mothers [$PM get_mothers]
     set to_be_deconnected 1
     foreach PM_mother $L_mothers {
       set LM_mother [$PM_mother get_LM]
       if {[string equal $LM_mother $objName]} {} else {set to_be_deconnected 0; break}
      }
     if {[expr $to_be_deconnected == 1 \
            && ![string equal $L_mothers {}]]} {
#     # It can only mean that L_mothers has only one element, which is the mother to remove
       $L_mothers Sub_daughter $PM
      }
    }
  }
 return $res
}

#_________________________________________________________________________________________________________
method Logical_model Is_PM_active {PM} {
 return [expr [lsearch $this(L_actives_PM) $PM] != -1]
}

#_________________________________________________________________________________________________________
method Logical_model set_PM_active   {PM} {set added [Add_element this(L_actives_PM) $PM]
                                           if {$added} {# Add PM in the hierarchy
                                                        this Add_PM $PM
                                                        $PM set_LM $objName
                                                        $PM Add_EE_successor [this get_Handle_EE]
                                                        # INSERT CALLBACKS HERE
                                                        return 1
                                                       }
                                           return 0
                                          }
method Logical_model set_PM_inactive {PM} {set subed [Sub_element this(L_actives_PM) $PM]
                                           if {$subed} {# Recursively sub in the PM hierarchy
                                                        #$PM set_LM {}
                                                        $PM Sub_EE_successor [this get_Handle_EE]
                                                        # INSERT CALLBACKS HERE
                                                        return 1
                                                       }
                                           return 0
                                          }

#_________________________________________________________________________________________________________
Manage_CallbackList Logical_model set_PM_active   INSERT
Manage_CallbackList Logical_model set_PM_inactive INSERT

#_________________________________________________________________________________________________________
method Logical_model get_L_actives_PM   {} {return $this(L_actives_PM)}
method Logical_model get_L_inactives_PM {} {set L [this get_L_PM]
                                            Sub_list L [this get_L_actives_PM]
                                            return $L
                                           }
method Logical_model set_L_actives_PM {L {soft_type {}}} {
 if {[string length $soft_type] == 0} {
   set this(L_actives_PM) {}
  } else {set L $this(L_actives_PM)
          foreach PM $L {
            if {[regexp "^$soft_type.*\$" [${PM}_cou_ptf get_soft_type] ]} {
              this set_PM_inactive $PM
             }
           }
         }
 foreach c $L {this set_PM_active $c}
}

#_________________________________________________________________________________________________________
method Logical_model get_L_compatible_PM_with_ptf {ptf} {
 set L [this get_L_PM]
 return [this get_L_compatible_PM_with_ptf_in $ptf L]
}
#_________________________________________________________________________________________________________
method Logical_model get_L_compatible_actives_PM_with_ptf {ptf} {
 return [this get_L_compatible_PM_with_ptf_in $ptf this(L_actives_PM)]
}
#_________________________________________________________________________________________________________
method Logical_model get_L_compatible_inactives_PM_with_ptf {ptf} {
 set L  [this get_L_inactives_PM]
 return [this get_L_compatible_PM_with_ptf_in $ptf L]
}

#_________________________________________________________________________________________________________
method Logical_model get_L_compatible_PM_with_ptf_in {ptf L_PM_name} {
 upvar $L_PM_name L_PM

 set rep {}
 foreach PM $L_PM {
   if {[${PM}_cou_ptf Accept_for_daughter $ptf]} {lappend rep $PM}
  }

 return $rep
}

#_________________________________________________________________________________________________________
method Logical_model get_L_PM_mothers_of_in {PM LM_M}  {
 set PMs_M    [$PM   get_mothers]
 set PMs_LM_M [$LM_M get_L_actives_PM]
 return [Liste_Intersection $PMs_M $PMs_LM_M]
}
#_________________________________________________________________________________________________________
method Logical_model get_L_PM    {}   {set rep [list]
                                       foreach e $this(L_PM) {
                                         lappend rep [lindex $e 0]
                                        }
                                       return $rep
                                      }
method Logical_model get_L_PM+   {}   {return $this(L_PM)}
method Logical_model get_PM_info {PM} {foreach e $this(L_PM) {
                                         if {[string equal $PM [lindex $e 0]} {
                                           return $e
                                          }
                                        }
                                      }
method Logical_model set_L_PM    {L}  {set L_PM [this get_L_PM]
                                       foreach PM $L_PM {this Sub_PM $PM}
                                       foreach PM $L    {this Add_PM $PM}
                                      }
#_________________________________________________________________________________________________________
method Logical_model get_a_unique_id {} {
 return [incr this(unique_PM_id)]
}
#_________________________________________________________________________________________________________
method Logical_model Add_PM {PM args}  {
 if {[string equal $PM ?]} {puts "Add_PM PM args\n  PM : A Physical Model compatible with $objName\n  args : -factory \"the command to create a new instance\"\n         -core \"Another PM of the same type, which is nested inside. This core PM is the one containing the right model to achieve the task. The PM in wich it is nested aims to provide a framework to do some styles.\""}
 if {[string equal [$PM get_LM] ""]} {} else {return 0}
 set PM_info $PM
 set ok 0
   set L_cmd [split $args -]
   foreach cmd $L_cmd {
     switch [lindex $cmd 0] {
#       factory {lappend this(L_PM_factories) [list [lindex $cmd 1] $PM]}
       core    {set ok 1; lappend PM_info    [lindex $cmd 1]}
      }
    }
 if {$ok} {} else {lappend PM_info $PM}
 set ok 0; set pos 0
 foreach e $this(L_PM) {
   if {[string equal $PM [lindex $e 0]]} {
     set this(L_PM) [lreplace $this(L_PM) $pos $pos $PM_info]
     set ok 1
     break
    }
   incr pos
  }

 if {$ok} {set added 0} else {set added [Add_element this(L_PM) $PM_info]}
 if {$added} {$PM set_LM $objName
              $PM set_Common_FC $this(FC)
              this Add_PM_factories [Generate_factories_for_PM_like $PM $objName]
              return 1
             }
 return 0
}
#_________________________________________________________________________________________________________
method Logical_model Sub_PM {PM}  {
 set pos 0
 foreach e $this(L_PM) {
   if {[expr [string equal $PM [lindex $e 0]] \
          || [string equal $PM [lindex $e 1]] ]} {
     $PM set_LM {}
     set this(L_PM) [lreplace $this(L_PM) $pos $pos]
     this set_PM_inactive $PM
     return 1
    }
   incr pos
  }

 return 0
}

#_________________________________________________________________________________________________________
method Logical_model Add_daughter_PM {PM LMD} {
# Find a valid PM in LMD to connect it to PM, wich is an active PM of objName
 this Add_daughter           $LMD
 this Add_PM                 $PM
 this set_PM_active          $PM
 this Connect_PM_descendants $PM $LMD
}

#_________________________________________________________________________________________________________
method Logical_model Try_to_connect_PM_with {PM PMDs index} {
 foreach PMD $PMDs {
   if {  [$PM  Accept_PM_for_daughter $PMD]  \
      && [$PM  Accept_more_daughters]        \
      && [$PMD Accept_more_mothers]          \
      } {
	    #puts "$objName Try_to_connect_PM_with $PM $PMDs $index => OK :\n  - $PM : [${PM}_cou_ptf get_soft_type]\n  - $PMD : [${PMD}_cou_ptf get_soft_type]"
         $PM Add_daughter $PMD $index
         return $PMD}
  }

 return {}
}

#_________________________________________________________________________________________________________
method Logical_model Connect_PM_descendants {{L_PM ""} {L_LM ""} {dec " "}} {
global debug
 if {$debug} {puts "$objName Connect_PM_descendants {$L_PM} {$L_LM}"}
 #puts "<${objName}::Connect_PM_descendants $L_PM>"
# puts "$dec$objName Connect_PM_descendants \{$L_PM\} \{$L_LM\}"
 if {[llength $L_PM] == 0} {set L_PM [this get_L_actives_PM]; if {$debug} {puts "${dec}L_PM <- $L_PM"}}
 if {[llength $L_LM] == 0} {set L_LM [this get_daughters];    if {$debug} {puts "${dec}L_LM <- $L_LM"}}

 set L_nested_LM [this get_handle_comet_daughters]

 foreach LMD $L_LM {
   set index [lsearch [this get_out_daughters] $LMD]
   if {$index == -1} {set index [lsearch [this get_daughters] $LMD]}
   foreach PM $L_PM {
#    Is this PM still pluged to LMD?
     # XXX CONDITION TROP FORTE DANS LE CAS OU IL Y A DES COMETS NESTEES ENTRE LES 2
     # XXX Prendre en compte la descendance au sens large, pas seulement les fils directs.
     if {[llength $L_nested_LM]>0} {
       set L_PMD [Liste_Intersection [$PM get_daughters] [$LMD get_L_actives_PM]]
      } else {set L_PMD [Liste_Intersection [$PM get_daughters] [$LMD get_L_actives_PM]]}
	 if {[string equal $L_PMD ""]} {set L_PMD [Liste_Intersection [$PM get_out_daughters] [$LMD get_L_actives_PM]]} 
     #XXX___________________________________________________________________________
     switch [llength $L_PMD] {
       0       {if {$debug} {puts "<${objName}::Connect_PM_descendants_CASE_0>"}
#              # Search among actives  PMs
                set PMD [this Try_to_connect_PM_with $PM [$LMD get_L_actives_PM] $index]
                if {[string length $PMD]} {if {$debug} {puts "  <$objName Connect_PM_descendants CASE 0-0 />"}
				                           $LMD Connect_PM_descendants $PMD
                                           if {$debug} {puts "</${objName}::Connect_PM_descendants_CASE_0>"}
										   continue
                                          }
#              # Search among inactive PMs
                set PMD [this Try_to_connect_PM_with $PM [$LMD get_L_inactives_PM] $index]
                if {[string length $PMD]} {if {$debug} {puts "  <$objName Connect_PM_descendants CASE 0-1 />"}
				                           $LMD set_PM_active $PMD
                                           $LMD Connect_PM_descendants $PMD
										   if {$debug} {puts "</${objName}::Connect_PM_descendants_CASE_0>"}
										   continue
                                          }
#              # Search among factories
#                puts "No PM in the daughter were found to plug as daughter to the current one ($PM)...We try to generate one"
                if {$debug} {puts "  <$objName Connect_PM_descendants CASE 0-2 />"}
				set L_factories [$LMD get_L_compatible_factories_with_ptf [${PM}_cou get_ptf]]
				if {$debug} {puts "  L_factories : {$L_factories}"}
                if {[llength $L_factories]} {
                  set PMD ""
                  foreach factory $L_factories {
                    set PMD [$factory Generate [$LMD get_LC] $LMD]
                    #puts "Logical_model Connect_PM_descendants, a PM has been factoried:\n  LM : $objName\n  $PMD"
                    if {[string length $PMD]} {break}
                   }
                  if {[string length $PMD]} {
                    #puts "  $PM Add_daughter $PMD created from factory"
                    if {[$PM Add_daughter $PMD $index]} {
                    #puts "  $LMD Connect_PM_descendants $PMD"
                      $LMD Connect_PM_descendants $PMD
					 }
                   }
                 }
				if {$debug} {puts "</${objName}::Connect_PM_descendants_CASE_0>" }
               }
       1       {
	            if {$debug} {puts "<${objName}::Connect_PM_descendants_CASE_1>"}
	            if {![string equal [$PM get_root_for_daughters] {}]} {
                  if {[$L_PMD Do_prims_still_exist]} {
                    if {[$PM Accept_PM_for_daughter $L_PMD]} {
                      $PM Reconnect $L_PMD
                     } else {$PM Sub_daughter $L_PMD
                             this Connect_PM_descendants $PM $LMD
                            }
                   } else {$PM Sub_daughter $L_PMD
                           #$PM Add_daughter $L_PMD $index
                           if {[string equal [this Try_to_connect_PM_with $PM $L_PMD $index] $L_PMD]} {} else {
                             this Connect_PM_descendants $PM $LMD
                            }
                           #puts "$PM _______________"
                          }
                 }
                $LMD Connect_PM_descendants $L_PMD
				if {$debug} {puts "</${objName}::Connect_PM_descendants_CASE_1>"}
               }
       default {puts "____ AU SECOURS !!! $PM  plusieurs fils chez $LMD ($L_PMD)!!!____"}
      }
    }
  }
 #puts "</${objName}::Connect_PM_descendants $L_PM>"
}

#_________________________________________________________________________________________________________
method Logical_model Substitute {PM1 PM2} {
 puts "$objName Substitute $PM1 $PM2"
 global debug
 set subed [this set_PM_inactive $PM1]
# XXXX
# this set_PM_active $PM1
# XXXX
 if {$subed} {
   set added [this set_PM_active $PM2]
   set L_pos [list]
   set L_PMM [$PM1 get_mothers]
#   puts "____Structure before changes____"; Afficher_structure $PM1
#   puts "** Let's manage mothers"
   foreach PMM $L_PMM {set LMM   [$PMM get_LM]
                       set L [$LMM get_daughters]
                       set pos [lsearch -exact $L $objName]
                       lappend L_pos $pos
                       set res [$PMM Sub_daughter $PM1]
                      #puts "$PMM Sub_daughter $PM1 : $res"
                       if {$debug} {puts "| $PMM Sub_daughter $PM1 : $res"}
                      }

   set L_PMD [$PM1 get_daughters]
   set L_LMD [this get_daughters]
   set L_pos [list]
#   puts "** Let's manage daughters"
#   puts "____Structure before subbing daughters____"; Afficher_structure $PM1
   foreach PMD $L_PMD {set LMD [$PMD get_LM]
                       set pos [lsearch -exact $L_LMD $LMD]
                       lappend L_pos $pos
                       set res [$PM1 Sub_daughter $PMD]
                      #puts "$PM1 Sub_daughter $PMD : $res"
                       if {$debug} {puts "| $PM1 Sub_daughter $PMD $pos : $res"}
                      }

   set index 0
#   puts "____Structure after subbing mothers____"; Afficher_structure $PM1
   foreach PMM $L_PMM {set pos [lindex $L_pos $index]
                       set res [$PMM Add_daughter $PM2 $pos]
                      #puts "$PMM Add_daughter $PM2 $pos : $res"
                       if {$debug} {puts "| $PMM Add_daughter $PM2 $pos : $res"}
                       incr index}

   set index 0
#   puts "____Structure after subbing daughters____"; Afficher_structure $PM1
   foreach PMD $L_PMD {set pos [lindex $L_pos $index]
                       set res [$PM2 Add_daughter $PMD $pos]
                      #puts "$PM2 Add_daughter $PMD $pos : $res"
                       if {$debug} {puts "| $PM2 Add_daughter $PMD $pos : $res"}
                       incr index}
#   puts "____Structure PM2 after all____"; Afficher_structure $PM2
   if {$debug} {puts "\n___________________________\n\
                      this Connect_PM_descendants"
               }
  }

 foreach LMM [this get_mothers] {
   $LMM Connect_PM_descendants $L_PMM $objName
   #XXX-OLD $LMM Connect_PM_descendants {} $objName
  }

 #END
}

#_________________________________________________________________________________________________________
method Logical_model Substitute {PM1 PM2} {
 #puts "<Logical_model:: $PM1 Substitute_by $PM2>"
 $PM1 Substitute_by $PM2
 #puts "</Logical_model:: $PM1 Substitute_by $PM2>"
}

#___________________________________________________________________________________________________________________________________________
#___________________________________________________________________________________________________________________________________________
method Logical_model EE_State_NoPM {proposer} {
 set nb_active_PM [llength $this(L_actives_PM)]
 if {[expr $nb_active_PM > 0]} {return {}}
 # Check if it is possible to plug this LM on one of its mothers
 foreach LM_M $this(L_mothers) {# Check if a PM can be plugged
                                foreach PM_M [$LM_M get_L_PM] {
                                  foreach PM [this get_L_PM] {if {[$PM_M Accept_for_daughter $PM]} {
                                                                # Propose to plug PM on PM_M
                                                                 set p [$proposer New_proposition]
                                                                 $p set_Conviction 0.8
                                                                 $p set_Author Conceptor
                                                                 $p set_Nature User_suitability
                                                                 $p set_Fonction "$LM_M Add_PM_daughter $PM"
                                                                 $proposer Add_action $p
                                                               }
                                                             }
                                 }
                               }
 return "$objName EE_State_NoPM $proposer"
}

#___________________________________________________________________________________________________________________________________________
#________________A state for an EE automat, replace a PM when its adequacy is under $threshold_min _________________________________________
#________________________the PM is replaced by another which adequacy is upper than threshold_ok____________________________________________
#___________________________________________________________________________________________________________________________________________
method Logical_model EE_State_ChooseBestPM {proposer threshold_min threshold_ok} {
## For each active MP, ask for the adequacy, if < 0.4 try to commut to another presentation
## Have to get the context
 #puts "  $objName EE_State_ChooseBestPM($proposer)"
 foreach PM $this(L_actives_PM) {
#   #puts " - PM=$PM"
   set stop 0
   foreach PMM [$PM get_mothers] {
     set context    "<mother>$PMM</mother>; <PM>$PM</PM>; ws_w=[$PMM get_width $PM]; ws_h=[$PMM get_height $PM];"
     set adequacy [$PM Adequacy $context]
#     #puts "   * PMM=$PMM, PM=$PM : Adequacy=$adequacy"
#     #puts "   * context=\"$context\""
     if {[expr $adequacy < $threshold_min]} {# Look for another presentation
       foreach Other_PM $this(L_PM) {
                                    #puts "     Could $Other_PM replace $PM?"
                                     set cou [$Other_PM get_cou]
#                                     #puts "Context : \"$context\""
                                     set other_adeq [$Other_PM Adequacy $context]
                                     if {[expr [$PMM Accept_for_daughter $cou]&&[$Other_PM Accept_more_mother]&&($other_adeq>$adequacy)]} {
                                      #puts "    <!!!> Proposing to replace $PM by $Other_PM, adequacy is $other_adeq <!!!>"
                                       set p [$proposer New_proposition]
                                       $p set_Conviction $adequacy
                                       $p set_Author Conceptor
                                       $p set_Nature User_suitability
                                       set cmd_prop "$objName Substitute $PM $Other_PM; puts {$PM was replaced by $Other_PM}"
#                                      #puts "     -> Ajout de \"$cmd_prop\""
                                       $p set_Fonction $cmd_prop
                                       $proposer Add_action $p
                                       set stop 1
                                       break
                                      } else {
#                                             #puts "       NOP :\n       $Other_PM adequacy is $other_adeq\n       $PMM Accept_for_daughter $cou:[$PMM Accept_for_daughter $cou]\n       $Other_PM Accept_more_mother:[$Other_PM Accept_more_mother]"
                                             }
        }
      }
    }
  }
 return "$objName EE_State_ChooseBestPM $proposer $threshold_min $threshold_ok"
}


#_________________________________________________________________________________________________________
#____________________________________________ Logical presentation_______________________________________________
#_________________________________________________________________________________________________________
inherit Logical_presentation Logical_model
method Logical_presentation constructor {name descr args} {
 this inherited $name $descr
 this set_composing_extension _LM_LP

 eval "$objName configure $args"
}

#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________


#_________________________________________________________________________________________________________
#_____________________________________________ Physical Model ____________________________________________
#_________________________________________________________________________________________________________
# Before all, let's define what is a platform, so we can use it in the concret model definition___________
#source context_of_use.tcl
#_________________________________________________________________________________________________________
inherit Physical_model Comet_element

#_________________________________________________________________________________________________________
method Physical_model constructor {name descr args} {
 this inherited $name $descr
 
 set this(Semantic_API_prim_set) ""
 
 set this(LM) ""
 set cou_name "${objName}_cou"
 COU $cou_name
 set this(cou) $cou_name
 set this(hiden_prim_elements) {}
 set this(primitives_handle) {}
 set this(nb_max_mothers) 1
 set this(nb_max_daughters) 99999999

 this set_cmd_placement {YOU_SHOULD_DEFINE_A_PLACEMENT_COMMAND}
 set this(cmd_deconnect) {}
 set this(root_for_daughters) NULL

 set this(L_propagate)    [list]
 this set_propagate_prev_liste_cmd "this get_LM"
 this set_propagate_next_liste_cmd ""

 set this(L_img) [list]

 eval "$objName configure $args"
 return $objName
}
#_________________________________________________________________________________________________________
method Physical_model dispose {} {
 #puts "$objName Physical_model::dispose";
 set LM [this get_LM]
 if {[string equal $LM {}]} {} else {$LM set_PM_inactive $objName
                                     $LM Sub_PM          $objName
                                    }

 set cou $this(cou)
 this inherited
 $cou dispose
}

#_________________________________________________________________________________________________________
Generate_accessors Physical_model [list hiden_prim_elements cmd_deconnect Semantic_API_prim_set]

#_________________________________________________________________________________________________________
method Physical_model get_PRIM_STYLE_CLASS {L_tags} {
 if {![this Has_MetaData PRIM_STYLE_CLASS]} {return ""}
 set rep {}
 set L_PRIM_STYLE_CLASS [this Val_MetaData PRIM_STYLE_CLASS]
 foreach tags $L_tags {
   set tags [split $tags .]
   foreach {prim L} $L_PRIM_STYLE_CLASS {
     if {[Is_sub_list $tags [concat * $L]]} {set rep [concat $rep $prim]}
    }
  }
 return $rep
}

#_________________________________________________________________________________________________________
method Physical_model Hide_Elements args {
 this Show_elements 0 *
 this Show_elements 1 *
 #puts "_____$objName Physical_model::Hide_Elements $args"
 if {[llength $args] > 0} {this Show_elements 0 $args}
 
 #set this(hiden_prim_elements) $args
 #puts "  END"
}

#_________________________________________________________________________________________________________
method Physical_model Show_elements {b L_tags} {
 #puts "$objName Physical_model::Show_elements {$b} {$L_tags}"
 if {$b == 0} {
   Add_list this(hiden_prim_elements) $L_tags
  } else {Sub_list this(hiden_prim_elements) $L_tags}
 if {[string equal $L_tags ""]} {
   this Show_elements_prims $b [this get_prim_handle]
  } else {set L_PM {}
          foreach tags $L_tags {set L_PM [concat $L_PM [CSS++ $objName "(#$objName\(> *->LC.$tags, (*->LC *.$tags) \))->PMs"]]}
		  foreach PM $L_PM {$PM Show_elements $b ""}
		  #puts "  Inner COMETs : {$L_PM}"
		  set L_prims [this get_PRIM_STYLE_CLASS $L_tags]
		  #puts "  Primitives : {$L_prims}"
		  if {![string equal $L_prims ""]} {this Show_elements_prims $b $L_prims}
         }
}

#_________________________________________________________________________________________________________
method Physical_model Show_elements_prims {b L_prims} {}

#_________________________________________________________________________________________________________
method Physical_model get_nesting_element {} {
 set rep [this inherited]
 if {[string equal $rep ""]} {
   set LM [this get_LM]
   if {![string equal $LM ""]} {return [$LM get_nesting_element]}
  }
 return $rep
}

#_________________________________________________________________________________________________________
method Physical_model Is_active {} {
 set LM [this get_LM]
 if {[string equal $LM {}]} {return 0}
 return [$LM Is_PM_active $objName]
}

#_________________________________________________________________________________________________________
method Physical_model Has_for_style {s} {
 if {[this inherited $s]} {return 1}
 if {$s == ""} {set s "{}"}
 return [eval [this get_LM] Has_for_style $s]
}

#_________________________________________________________________________________________________________
method Physical_model Substitute_by_PM_type {t} {
#puts "$objName Physical_model::Substitute_by_PM_type $t"
# Look if a t PM is ammong inactives PM of the related LM
 set LM [this get_LM]
 set new_PM {}
 foreach PM [$LM get_L_inactives_PM] {
   if {[lsearch [gmlObject info classes $PM] $t] != -1} {set new_PM $PM; break;}
  }
 if {[string equal $new_PM {}]} {
   set new_PM [this get_LC]_PM_P_${t}_[$LM get_a_unique_id]
   $t $new_PM $new_PM "Created to substitute $objName as a PM of type $t"
  }

 this Substitute_by $new_PM
 return $new_PM
}

#_________________________________________________________________________________________________________
method Physical_model Propagate_info_substitution_of {PM1 PM2} {
 #puts "<${objName}::Propagate_info_substitution_of>"
 foreach m [this get_mothers] {
   $m Propagate_info_substitution_of $PM1 $PM2
  }
 #puts "</${objName}::Propagate_info_substitution_of>"
}

#_________________________________________________________________________________________________________
method Physical_model Substitute_by {PM} {
 #puts "$objName Physical_model::Substitute_by $PM"
 if {[string equal $PM {}]} {return}
 set L_roots [this get_L_roots]
 set LM [this get_LM]
 if {![string equal $LM ""]} {
   $LM Add_PM          $PM
   $LM set_PM_active   $PM
   $LM set_PM_inactive $objName
   foreach mtd [gmlObject info methods $objName] {
     if {[string equal -length 9 $mtd get_L_CB_]} {
	   if {[lsearch [gmlObject info methods $PM] $mtd] >= 0} {
	     set mtd_set [string replace $mtd 0 0 s]
		 set L_CB {}
		 foreach CB [this $mtd] {
		   if {[string equal -length 14 __FOREACH_PM__ [lindex $CB 0]]} {lappend L_CB $CB}
          }
		 set L_CB [string map [list $objName $PM] $L_CB]
		 $PM $mtd_set $L_CB
	    }
	  }
    }
  }

 # Can the new PM plugs the current daughters
  set do_it_classically 1
  if {[this get_nb_daughters] > 0} {
    set fils [lindex [this get_out_daughters] 0]
	if {![${PM}_cou_ptf Accept_for_daughter ${fils}_cou_ptf]} {
	  set do_it_classically 0
	 }
   }
  
  if {$do_it_classically} {
    this inherited $PM
   } else {this set_daughters ""
           this inherited $PM
           $LM Connect_PM_descendants [list $PM] [$LM get_daughters]
          }


  if {![string equal $LM ""]} {
   $LM set_PM_inactive $objName
  }
 $PM Propagate_info_substitution_of $objName $PM
 #puts "</${objName}::Physical_model::Substitute_by $PM>"
}

#_________________________________________________________________________________________________________
method Physical_model get_nesting_CORE_LC {} {
 set nesting [this get_nesting_element]
 if {![string equal $nesting ""]} {
   if {[lsearch [gmlObject info classes $nesting] PM_U_encapsulator] != -1} {
     if {[string equal [$nesting get_core] $objName]} {return [$nesting get_nesting_LC]}
   	} 
  }
 return [this get_LC]
}

#_________________________________________________________________________________________________________
method Physical_model get_nesting_LC {} {
 set nesting [this get_nesting_element]
 if {![string equal $nesting ""]} {
   return [$nesting get_nesting_LC]
  }
 return [this get_LC]
}

#_________________________________________________________________________________________________________
method Physical_model Reconnect {PMD} {RECONNECT HAS TO BE SPECIFYED!!!!}

#_________________________________________________________________________________________________________
method Physical_model get_L_img { } {return $this(L_img)}
method Physical_model set_L_img {L} {return [set this(L_img) $L]}
method Physical_model add_L_img {L} {return [Add_list this(L_img) $L]}
method Physical_model sub_L_img {L} {return [Sub_list this(L_img) $L]}

#_________________________________________________________________________________________________________
method Physical_model get_Common_FC {}   {if {[string equal $this(LM) {}]} {return ""}
                                          set LC [$this(LM) get_LC]
                                          return [$LC get_Common_FC]}
#_________________________________________________________________________________________________________
method Physical_model get_width  {{PM {}}} {return -1}
method Physical_model get_height {{PM {}}} {return -1}
#_________________________________________________________________________________________________________
method Physical_model get_ideal_height {} {return 0}
method Physical_model get_ideal_width  {} {return 0}
#_________________________________________________________________________________________________________
method Physical_model Adequacy {contexte {force_eval_ctx 0}} {return -1}
#_________________________________________________________________________________________________________
method Physical_model get_context {} {return {}}
#_________________________________________________________________________________________________________
method Physical_model get_LM {}   {return $this(LM)}
method Physical_model set_LM {LM} {set this(LM) $LM; 
                                   if {$LM != ""} {
								     set this(names_obj) [list $objName [this get_LM] [this get_LC]]
									 this set_Common_FC [$LM get_Common_FC]
									}
                                   return $LM}
#_________________________________________________________________________________________________________
method Physical_model get_LC {}   {return [$this(LM) get_LC]}

#_________________________________________________________________________________________________________
method Physical_model get_real_LC {} {
 set LC [this get_LC]
 if {[$LC Has_MetaData Core_of_PM]} {
   return [[$LC Val_MetaData Core_of_PM] get_LC]
  } else {return $LC}
}

#_________________________________________________________________________________________________________
method Physical_model get_cou {} {return $this(cou)}
method Physical_model Accept_for_daughter {cou} {return [$this(cou) Accept_for_daughter $cou]}
method Physical_model Accept_PM_for_daughter {PM} {set cou [$PM get_cou]
                                                   return [$this(cou) Accept_for_daughter $cou]}
#_________________________________________________________________________________________________________
method Physical_model get_root_for_daughters {{index -1}}    {return $this(root_for_daughters)}
method Physical_model set_root_for_daughters {r {index -1}}  {set this(root_for_daughters) $r}
#_________________________________________________________________________________________________________
method Physical_model get_prim_handle {{index -1}}  {return $this(primitives_handle)}
method Physical_model set_prim_handle {h}           {set this(primitives_handle) $h; return $h}
#_________________________________________________________________________________________________________
method Physical_model get_mothers {}  {return $this(L_mothers)}
method Physical_model set_L_mothers {l} {set this(L_mothers) $l; return $l}
#_________________________________________________________________________________________________________
method Physical_model get_cmd_placement {}  {return $this(cmd_placement)}
method Physical_model set_cmd_placement {c} {set this(cmd_placement) $c}
#_________________________________________________________________________________________________________
method Physical_model get_or_create_prims {root} {return [this get_prim_handle]}
method Physical_model Add_prim_mother   {c Lprims {index -1}} {return 1}
method Physical_model Sub_prim_mother   {c Lprims {index -1}} {return 1}
method Physical_model Add_prim_daughter {c Lprims {index -1}} {set rep 1
                                                             foreach p $Lprims {
                                                               if {[string equal $p NULL]} {continue}
                                                               if {[catch {eval $this(cmd_placement)} err]} {
                                                                 #puts " XXX ERROR XXX $objName Add_prim_daughter \{$Lprims\} $index"
                                                                 #puts "               $err"
                                                                 set rep 0
                                                                }
                                                              }
                                                             return $rep
                                                            }
method Physical_model Sub_prim_daughter {c Lprims {index -1}} {}

Manage_CallbackList Physical_model [list Add_prim_mother] begin
#_________________________________________________________________________________________________________
method Physical_model Do_prims_still_exist {} {
 return 1
}
#_________________________________________________________________________________________________________
method Physical_model Is_still_branched_to {prim} {
 return [this Do_prims_still_exist]
}

#_________________________________________________________________________________________________________
method Physical_model Add_daughter    {m {index -1}} {
global debug
                                                      if {$debug} {puts "  $objName Physical_model::Add_daughter $m $index"}
                                                      set rep [this inherited $m $index]
                                                      if {$rep == 1} {set root [this get_root_for_daughters]
                                                                      if {$debug} {puts "    root : $root"}
																	  if {[string equal $root {}]} {return 1}
                                                                             if {[string equal $root NULL]} {this Sub_daughter $m;
                                                                                                             if {$debug} {puts "   !!! : La racine d'attache des fils de $objName est NULL, on retire $m"}
                                                                                                             return 0}
#                                                                             set prev_prim_daughters [$m get_prim_handle $root]
                                                                             set prev_exists    [$m Do_prims_still_exist]
                                                                             set prim_daughters [$m get_or_create_prims $root]
                                                                             if {[string equal $prim_daughters NULL]} {this Sub_daughter $m;
                                                                                                                       if {$debug} {puts "   !!! $objName : La poigne de $m est NULL, on le retire"}
                                                                                                                       return 0}

                                                                             $this(LM) set_PM_active $objName
                                                                             if {$prev_exists} {
                                                                               if {[$m Is_still_branched_to $root]} {
                                                                                 if {$debug} {puts "    STILL BRANCHED"}
																				 return 2
                                                                                } else {if {$debug} {puts "    PREV EXISTS"
																				                     puts "    $objName Add_prim_daughter $m       $prim_daughters $index"
																									}
																				        this Add_prim_daughter $m       $prim_daughters $index
																						if {$debug} {puts "    $m   Add_prim_mother   $objName $root"}
                                                                                        $m   Add_prim_mother   $objName $root
                                                                                        return 1
                                                                                       }
                                                                              } else {
																			     if {$debug} {puts "    NON PREV EXISTS"}
                                                                                 this Add_prim_daughter $m       $prim_daughters $index
																				 if {$debug} {puts "    $m   Add_prim_mother   $objName $root"}
                                                                                 $m   Add_prim_mother   $objName $root
                                                                                 return 1
                                                                                }
                                                                            } else {if {$debug} {puts "    initial rep == $rep"}}
                                                      if {$debug} {puts "    => $rep"}
													  return $rep
                                                     }
#_________________________________________________________________________________________________________
method Physical_model Sub_daughter    {m} {global debug
										   if {$debug} {puts "$objName Physical_model::Sub_daughter $m"}
										   set rep [this inherited $m]
                                           if {[expr $rep == 1]} {set pos [lsearch $this(L_mothers) $m]
										                            
																    if {$debug} {puts "$objName Sub_prim_daughter $m {[$m get_prim_handle $pos]} $pos"}
                                                                  this Sub_prim_daughter $m [$m get_prim_handle $pos] $pos
#                                                                  #$m set_prim_handle NULL
                                                                  return 1}
                                           return 0}

#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
#_________________________________________________________________________________________________________
# Fonctions d'affichage de la structure
proc Connection {comet {L_LM _LM_LP}} {
 foreach suffixe $L_LM {
   $comet           Connect_LM_descendants $suffixe
   "$comet$suffixe" Connect_PM_descendants
  }

}

#_________________________________________________________________________________________________________
proc Afficher_structure {racine {cmd {puts "$dec*$racine"}} {dec ""}} {
 eval $cmd
 append dec " |"
 foreach n [$racine get_daughters] {Afficher_structure $n $cmd $dec}
}

proc dispose_all {racine {cmd {puts "$dec*$racine"}} {dec ""}} {
 eval $cmd
 append dec " |"
 foreach n [$racine get_daughters] {dispose_all $n $cmd $dec}
 $racine dispose
}

